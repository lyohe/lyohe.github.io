{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2021-03-17-javascript-nanimo-wakaranai/",
    "result": {"data":{"site":{"siteMetadata":{"title":"ここにかく"}},"markdownRemark":{"id":"97d68a7a-727a-54cd-9246-ae3d919bb8b7","excerpt":"JavaScript は奥が深い。以前このブログに「JavaScript はそれほど難しくないと思う」と書いたが、全くそんなことはなかった。 発端 React と Redux のドキュメントや関連するブログを読んでいると、しつこいくらい immutable や immutability…","html":"<p>JavaScript は奥が深い。<a href=\"https://lyohe.github.io/post/2021-02-04-programming-taihenda/\">以前このブログに「JavaScript はそれほど難しくないと思う」と書いた</a>が、全くそんなことはなかった。</p>\n<h2 id=\"発端\" style=\"position:relative;\"><a href=\"#%E7%99%BA%E7%AB%AF\" aria-label=\"発端 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>発端</h2>\n<p>React と Redux のドキュメントや関連するブログを読んでいると、しつこいくらい <em>immutable</em> や <em>immutability</em> という単語が登場する。</p>\n<p><em>immutable</em> は <em>mutable</em> の対義語。 <em>mutable</em> は <em>mutate</em> + <em>-able</em> で、 <em>mutate</em> は「ミュータント - mutant」という言葉に使われるように「変異する」という意味。ちなみにこの単語はニューヨークの下水道で暮らす亀が忍者に変異して悪と戦うアニメで覚えた。</p>\n<p><em>immutable</em> はその対義語なので「不変性」を意味しており、要は「あるオブジェクトの中身を直接書き換える（<em>mutate</em>）のではなくて、そのコピーを作ってそれを書き換えなさい」ということを指している。一般的に、 JavaScript において object を immutable update することにはいくつかのメリットがある。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Immutable\">https://developer.mozilla.org/en-US/docs/Glossary/Immutable</a></p>\n<p>実は <a href=\"https://ja.reactjs.org/tutorial/tutorial.html#why-immutability-is-important\">React のチュートリアルでも immutability の重要性について説明されている</a>のだが、私はなぜそれが必要なのかを深く理解しないままやり過ごしてきた。</p>\n<p>しかし、どうも気になる…なんでわざわざこんな事をしなければならんのか。ということで、調べてブログに書くことにした。</p>\n<h2 id=\"javascript-における-immutability\" style=\"position:relative;\"><a href=\"#javascript-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability\" aria-label=\"javascript における immutability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript における immutability</h2>\n<p>React や Redux における immutability の重要性について調べる前に、まずは JavaScript の基本を学ぶ。</p>\n<p>JavaScript において、値は必ず <code class=\"language-text\">primitive</code> か <code class=\"language-text\">object</code> のいずれかになる。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></p>\n<p>primitive は以下の7種類のデータ型で、これらに該当しない値が object となる。</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>bigint</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>symbol</li>\n<li>null</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a></p>\n<p>primitive は「immutable」で object は「mutable」という互いに異なる性質を持つ。</p>\n<h3 id=\"primitive-の-immutability\" style=\"position:relative;\"><a href=\"#primitive-%E3%81%AE-immutability\" aria-label=\"primitive の immutability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>primitive の immutability</h3>\n<p>primitive である文字列 <code class=\"language-text\">Hello</code> に別の文字列 <code class=\"language-text\">, World!</code> を連結すると、新しくできた文字列 <code class=\"language-text\">Hello, World!</code> は元々の2つの文字列とは全く別の新しい文字列として作られる。文字列 <code class=\"language-text\">Hello</code> が直接 mutate されるわけではない。これはC言語とは異なる。</p>\n<p>実際の例を見てみる。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> immutableString <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n\nimmutableString <span class=\"token operator\">=</span> immutableString <span class=\"token operator\">+</span> <span class=\"token string\">\", World!\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// update</span></code></pre></div>\n<p>上記のコードで変数 immutableString の update 時には</p>\n<ol>\n<li>変数 immutableString の値 <code class=\"language-text\">Hello</code> を取得し</li>\n<li><code class=\"language-text\">, World!</code> という値を <code class=\"language-text\">1.</code> の値に追加し</li>\n<li><code class=\"language-text\">2.</code> の結果を新しく確保されたメモリに割当て</li>\n<li>変数 immutableString が <code class=\"language-text\">3.</code> のメモリを参照し</li>\n<li>ガベージコレクション（以下 GC と呼ぶ）が update 前の参照先である <code class=\"language-text\">1.</code> のメモリを解放して利用可能にする</li>\n</ol>\n<p>という処理が行われる。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Mutable\">https://developer.mozilla.org/en-US/docs/Glossary/Mutable</a></p>\n<h3 id=\"object-の-mutability\" style=\"position:relative;\"><a href=\"#object-%E3%81%AE-mutability\" aria-label=\"object の mutability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>object の mutability</h3>\n<p>object は mutable であり、そのプロパティ（や Array の要素）は変更することができる。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> book1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> <span class=\"token string\">'The Road of the Rings'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nbook1<span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> <span class=\"token string\">'The Lord of the Rings'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { title: 'The Lord of the Rings' }</span></code></pre></div>\n<p>object は値への参照とみなすこともできる。下記のように、ある object がそのプロパティとして持つ値が等しくても、 object の参照先が等しくなければそれは異なる object となる。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> book1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> <span class=\"token string\">'The Lord of the Rings'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> book2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> <span class=\"token string\">'Harry Potter'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nbook2<span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> <span class=\"token string\">'The Lord of the Rings'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1 <span class=\"token operator\">===</span> book2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1<span class=\"token punctuation\">.</span>title <span class=\"token operator\">===</span> book2<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true </span></code></pre></div>\n<p>下記の例では book1 と book3 は同じ参照先を持つ object なので、 book3.title を mutate すると book1.title も同時に mutate される。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> book1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> <span class=\"token string\">'The Lord of the Rings'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> book3 <span class=\"token operator\">=</span> book1<span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1 <span class=\"token operator\">===</span> book3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nbook3<span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> <span class=\"token string\">'The Chronicles of Narnia'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1 <span class=\"token operator\">===</span> book3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { title: 'The Chronicles of Narnia' }</span></code></pre></div>\n<p>このように、「object は mutable である」とは「object の参照先を変えないまま参照先の値を書き換えることができる」と言い換えることができる。</p>\n<h2 id=\"react-における-immutability-の重要性\" style=\"position:relative;\"><a href=\"#react-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability-%E3%81%AE%E9%87%8D%E8%A6%81%E6%80%A7\" aria-label=\"react における immutability の重要性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React における immutability の重要性</h2>\n<p>本記事の冒頭で挙げたように、 React において「なぜ immutability が重要なのか」という理由はチュートリアルに書いてある。それによると、 object を immutable update することで</p>\n<ol>\n<li>変更履歴を活用するような機能を簡単に実装できる</li>\n<li>（React が）簡単にオブジェクトの変更を検出できる</li>\n<li><code class=\"language-text\">2.</code> によって（React が）コンポーネントをいつ再描画するかを決定しやすくなる</li>\n</ol>\n<p>というメリットがあるそうだ。</p>\n<p><a href=\"https://ja.reactjs.org/tutorial/tutorial.html#why-immutability-is-important\">https://ja.reactjs.org/tutorial/tutorial.html#why-immutability-is-important</a></p>\n<p>上記のうち 1. は自明だが 2. と 3. については React 内部の動作を知らないと納得がいかないと思う。自分はここを深く理解せず思考停止で immutable update をしていた。</p>\n<p>React.Component では shouldComponentUpdate() という API を通じて、いつ再描画すべきかをコンポーネントに伝えている。この shouldComponentUpdate() はコンポーネントの引数（props）か状態（state）が更新される度に render() の前に呼び出されて真偽値（デフォルトは true）を返し、これが false を返す場合は render() が実行されず再描画されない。</p>\n<p><a href=\"https://ja.reactjs.org/docs/react-component.html#shouldcomponentupdate\">https://ja.reactjs.org/docs/react-component.html#shouldcomponentupdate</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5b364e3cd846b982e8f3384824a1aabe/22c86/lifecycle-diagram.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.08860759493672%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLklEQVQ4y22TiXKjMAyG8/4vt2m3uZoLkkC4AzY+MCTfjt1NZo9qRiMw8udfspjx2x6PB99ZcVNkWU5V1ZRlRZKkVHXNNE3f5s/+hN3vd8ZxZJwmpumOcyNC9nSdoO97RNfR1A1CCIZhCFDvft8zzjzsCfRJ7a3mFEfcmgqtFEqpsJ4XBXF8Cu/W2nCAlJLLJSGKYuqmwTn3pfBp2jj2meF9V7C9aqSyGCXRqsdqhehuaCVD7HuJMQatdYD7GIBenbUD0ziizMD2allEHbts4FIq4qQiSirSUpAUgrzRxNeWVvQvoFft4+CBfvFwiLheM5QeiApHXDriauQz6Xk/dvyMJMvEsk4dh2JknzuaTmON/gsYFA6DI88Lbrc29MpZhdWS0WqmQXMqej6ODcvNlUXUfG00IrRBa/M/8M8ehpIzxya17DLHLnesLoaPWPF5MuxLgq/Tkboz3yv0N9a2XfBeaWoxULY2xKobqOqCPD9zzVPOl5gsT2iaHCG6l8LnpfgKZ8ZYirKkrhuGwcLoy21f8aFjJvmJaVboeoHrNqC3ONMyTQ/u9ynM7nMmZ16mn7G6uXEfLQ8dMcpDAMlyRVtsENUW3R6Z1AlswkOfcVa+WuUH2tsLmKZX6qrBOsvivOLH7p2P0xKhFbnMOVQHlucl8/0bq8uaY3NEasmpjHk7zJnv5mySNW7851L8CVKJL9ciJPjnuq3JipZWdvRaomwfvmmrESFX0us+/Hq/ANBt5LY6rnCpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"component-lifecycle-diagram\"\n        title=\"component-lifecycle-diagram\"\n        src=\"/static/5b364e3cd846b982e8f3384824a1aabe/f058b/lifecycle-diagram.png\"\n        srcset=\"/static/5b364e3cd846b982e8f3384824a1aabe/c26ae/lifecycle-diagram.png 158w,\n/static/5b364e3cd846b982e8f3384824a1aabe/6bdcf/lifecycle-diagram.png 315w,\n/static/5b364e3cd846b982e8f3384824a1aabe/f058b/lifecycle-diagram.png 630w,\n/static/5b364e3cd846b982e8f3384824a1aabe/40601/lifecycle-diagram.png 945w,\n/static/5b364e3cd846b982e8f3384824a1aabe/22c86/lifecycle-diagram.png 1143w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>上の図は↓から引用した。</p>\n<p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>\n<p>shouldComponentUpdate() の詳細な動作についてはドキュメントで説明されている。これによると、ツリー状に連なったコンポーネントにおいて shouldComponentUpdate() の結果が true かつ描画される React 要素が等しいかどうかで Reconciliation （差分を検出する処理）を実行するかを判定している。</p>\n<p><a href=\"https://ja.reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action\">https://ja.reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action</a></p>\n<p>Reconciliation の詳細な仕組みについてもドキュメントに記載されている。ツリー構造の全体で差分比較をすることは計算コストが高すぎる（ドキュメントによるとツリーの要素数を n として O(n^3) らしい）ので、 React ではツリーの差分検出を O(n) 程度の計算量で行うためにいくつかの前提を置いているそうだ。</p>\n<p><a href=\"https://ja.reactjs.org/docs/reconciliation.html\">https://ja.reactjs.org/docs/reconciliation.html</a></p>\n<p>Reconciliation の結果として「差分がある」ということになれば、 React は render() が返す JSX <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>を使って生成した DOM で実 DOM を更新する。</p>\n<p>このようなコンポーネントのライフサイクルを見ると、 React において immutability が重要である詳細な理由が見えてくる。それは、「<strong>props や state の更新が行われるたびに</strong>」 shouldComponentUpdate() が呼び出されることにある。shouldComponentUpdate() が呼び出されれば、それはデフォルトで true を返す。すると React は render() を呼び出し JSX を得る。React はその結果を使って Reconciliation を行い、差分があれば実 DOM を更新する。ここで、ライフサイクルの最初で props や state が変わったことをどのように検出するかという問題がある。JavaScript の object は mutable で、その参照先を書き換えた上で書き換え前の object と比較しても等しいままなのであった。</p>\n<p>論理的には object のプロパティを辿ってその一つ一つを比較することで object が更新されたかどうかを検出することは可能ではあるものの、現実的には計算コストが高そうで、要素数が n なら <strong>O(n)</strong> の計算量になるはずだ。この点、 immutable な更新を行えば参照が異なるというだけで中身を見なくても変更されていることが分かるので、この前提を守るだけで非常に少ない計算コスト <strong>O(1)</strong> で変更を検出できることが分かる。</p>\n<p>具体例としては、 React では state object の中身を（setState 関数を使わずに）直接 mutate しても DOM は再描画されないという仕様がある。これは、 setState が state object の immutable な更新を行っているが、この state object を直接書き換えるとその参照先は同じなので（React からすると）変わったように見えないからだ。</p>\n<p><a href=\"https://ja.reactjs.org/docs/state-and-lifecycle.html#do-not-modify-state-directly\">https://ja.reactjs.org/docs/state-and-lifecycle.html#do-not-modify-state-directly</a></p>\n<h3 id=\"redux-における-immutability-の重要性\" style=\"position:relative;\"><a href=\"#redux-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability-%E3%81%AE%E9%87%8D%E8%A6%81%E6%80%A7\" aria-label=\"redux における immutability の重要性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux における immutability の重要性</h3>\n<p>実世界で React コンポーネントを作るときはクラスで状態を持つことは少なく、多くのコンポーネントは props を受け取り JSX を返す関数として構成され、少数の閉じたコンポーネントで使う状態は React Hooks で、コンポーネントツリー内のあちこちで共通の状態を使い回すのであれば Redux 等のライブラリで状態を管理することになると思う。</p>\n<p>Redux で管理する状態は Store と呼ばれるグローバルな単一の object に統一されている。この Store は Reducer と呼ばれる、 Action と現在の状態を引数に取り新しい状態を返す関数によってのみ更新される。 Action は Reducer が識別に使うための type 要素を持つ単なる JavaScript object で、 UI 等から呼び出される Dispatch と呼ばれる関数によって Store に送られる。</p>\n<p><a href=\"https://redux.js.org/tutorials/essentials/part-1-overview-concepts\">https://redux.js.org/tutorials/essentials/part-1-overview-concepts</a></p>\n<p><img src=\"/c98922b5a476e12b853576324f12f5c4/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif\" alt=\"redux-dataflow-diagram\"></p>\n<p>Redux において immutability が重要になるのは、 object を直接 mutate するようなコードが React-Redux のような Redux の Store に依存するライブラリにおいて様々な問題を引き起こすためとドキュメントには書かれている。 React-Redux では root state object を shallow check することで state をラップするコンポーネントの再描画が必要かどうかを検出するため、直接 mutate していると再描画がトリガーされない。</p>\n<p><a href=\"https://redux.js.org/faq/immutable-data#does-shallow-equality-checking-with-a-mutable-object-cause-problems-with-redux\">https://redux.js.org/faq/immutable-data#does-shallow-equality-checking-with-a-mutable-object-cause-problems-with-redux</a></p>\n<h4 id=\"redux-toolkit-を使う\" style=\"position:relative;\"><a href=\"#redux-toolkit-%E3%82%92%E4%BD%BF%E3%81%86\" aria-label=\"redux toolkit を使う permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux-Toolkit を使う</h4>\n<p>上記のように、 Redux においても object を immutable update することが重要だ。</p>\n<p>しかし、実世界で Redux アプリケーションを作る際に使うであろう Redux Toolkit の createSlice や createReducer は内部で <a href=\"https://github.com/immerjs/immer\">Immer</a> を使っていて、その中では object を mutate するようなコードを書いたとしても Immer が immutability を担保してくれるので開発者側からすると意識しないかもしれない…これを知らずに自力で state の immutable update を試みるとかえって余計なバグを生み出しそうだ。つまり、 immutability は重要だが、必ずしもそれを担保するコードを自分で書く必要はない。</p>\n<p><a href=\"https://redux.js.org/tutorials/fundamentals/part-8-modern-redux#writing-slices\">https://redux.js.org/tutorials/fundamentals/part-8-modern-redux#writing-slices</a></p>\n<p>Immer は現在の状態と次の状態の間を取り持つ proxy を用意し、開発者が試みた全ての変更を追跡し安全に immutable update をしてくれる。</p>\n<p><a href=\"https://hackernoon.com/introducing-immer-immutability-the-easy-way-9d73d8f71cb3\">https://hackernoon.com/introducing-immer-immutability-the-easy-way-9d73d8f71cb3</a></p>\n<p>ちなみに Immer の名前は immutable から取ってるのかなと思ったら、（それもあるだろうけど）ドイツ語で「いつも」という意味でもあるらしい。名前の付け方がおしゃれだ…</p>\n<p><a href=\"https://immerjs.github.io/immer/docs/introduction\">https://immerjs.github.io/immer/docs/introduction</a></p>\n<h2 id=\"おまけ-javascript-のメモリ管理\" style=\"position:relative;\"><a href=\"#%E3%81%8A%E3%81%BE%E3%81%91-javascript-%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86\" aria-label=\"おまけ javascript のメモリ管理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>おまけ: JavaScript のメモリ管理</h2>\n<p>プログラミングを始めたばかりの頃にC言語を使って libc の再実装をやっていた時期があって、そのときは malloc や calloc でメモリを確保して free で解放するプログラムを書いていた。普段 JavaScript や TypeScript を書いているとメモリ管理について意識することが少ないのだが、この機会にどうなっているのか調べてみた。</p>\n<p>JavaScript では object の生成時に自動的にメモリを割り当て、それが “不要” になると GC によって自動的にメモリが解放される。 GC が既に割り当てられたメモリを “不要” とするアルゴリズムはいろいろある。</p>\n<p>例えば、 Reference-counting と呼ばれるやり方では、「ある object が他の object から参照されていない（つまり reference-count が 0 である）」ことを以てその object を “不要” とみなす。これは一見うまく行くように見えるが、 object 間に循環参照がある場合 GC の対象にならないという欠点がある。</p>\n<p>Mark-and-sweep algorithm と呼ばれるやり方では、 root と呼ばれる global object からスタートして参照を辿り、そこから到達不可能な object を “不要” とみなしてメモリを解放する。 root から到達可能かどうかによって GC の必要性を判断するので、お互いにお互いを参照する object が存在してもそれが root から到達不可能であれば GC の対象となる。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management</a></p>\n<h3 id=\"gc-があってもメモリ管理は必要\" style=\"position:relative;\"><a href=\"#gc-%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E3%81%AF%E5%BF%85%E8%A6%81\" aria-label=\"gc があってもメモリ管理は必要 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC があってもメモリ管理は必要</h3>\n<p>何を今更という話かもしれないが、上記の通り JavaScript はメモリの割当や解放を勝手にやってくれるだけで、それはメモリ管理についての配慮が不要であることを意味しない。</p>\n<p>例えば GC のアルゴリズムでは “不要” とみなされないが開発者や利用者の視点からは “不要” なメモリをたくさん確保しそれらを解放しないまま動作し続けるようなプログラムを実行したらクラッシュするだろう。</p>\n<p>家にゴミ箱があっても、ちゃんとゴミ箱に捨てて収集日にゴミ出しする習慣が無いと家がゴミだらけになってしまう。</p>\n<h3 id=\"gc-以外のメモリ管理方法-rust\" style=\"position:relative;\"><a href=\"#gc-%E4%BB%A5%E5%A4%96%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95-rust\" aria-label=\"gc 以外のメモリ管理方法 rust permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC 以外のメモリ管理方法: Rust</h3>\n<p>最近ちょっとだけ Rust の勉強をした。といっても <a href=\"https://doc.rust-jp.rs/book-ja/title-page.html\">The Rust Programming Language 日本語版</a>を一通り読んだだけだが…</p>\n<p>Rust には JavaScript のような GC が存在しない。ではどうやって “不要” なメモリを OS に返却し再割当可能にしているかというと、「所有権 - Ownership」という独特な仕組みが用意されている。 Rust の値は「所有者 - Owner」と呼ばれる変数と対応している。所有者は必ず1つの変数で、その変数がスコープを抜けたらメモリは自動的に解放される。</p>\n<p><a href=\"https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html\">https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html</a></p>\n<p>Rust は所有権を中心に様々な特殊な文法を持っていて、解放されたメモリにアクセスしたり確保されたメモリを二重に解放してしまうようなメモリ関連のバグを強制的に防ぐことができる。つまり言語仕様のレベルでメモリの安全性が担保されている。コンパイルの段階つまりプログラムの実行前にそれを知ることができるので、とても便利だ。</p>\n<p>仕事で使うことは無さそうだが、面白かったので引き続き勉強して趣味で使おうと思う。</p>\n<h2 id=\"プログラミングは奥が深い\" style=\"position:relative;\"><a href=\"#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E5%A5%A5%E3%81%8C%E6%B7%B1%E3%81%84\" aria-label=\"プログラミングは奥が深い permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>プログラミングは奥が深い</h2>\n<p>プログラミング、たぶん一生理解できないまま寿命かやる気のどっちかが尽きるんだろうな〜という思いがある。</p>\n<p>今回はドキュメントベースで勉強していったけど、直接いじりながら動かした方がドキュメント化されていない挙動を確認したり詳細を理解できるので勉強になりそうだ。 <a href=\"https://preactjs.com/\">preact</a> という小さな React があるので、時間があるときに触ってみたい。</p>\n<p>あと私は初心者なのでこの記事に間違いあったらすみません。各自の責任で調べて下さい。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">実は <a href=\"https://ja.reactjs.org/docs/react-without-jsx.html\">JSX を使わずに React を使うこともできる</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E7%99%BA%E7%AB%AF\">発端</a></p>\n</li>\n<li>\n<p><a href=\"#javascript-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability\">JavaScript における immutability</a></p>\n<ul>\n<li><a href=\"#primitive-%E3%81%AE-immutability\">primitive の immutability</a></li>\n<li><a href=\"#object-%E3%81%AE-mutability\">object の mutability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#react-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability-%E3%81%AE%E9%87%8D%E8%A6%81%E6%80%A7\">React における immutability の重要性</a></p>\n<ul>\n<li>\n<p><a href=\"#redux-%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-immutability-%E3%81%AE%E9%87%8D%E8%A6%81%E6%80%A7\">Redux における immutability の重要性</a></p>\n<ul>\n<li><a href=\"#redux-toolkit-%E3%82%92%E4%BD%BF%E3%81%86\">Redux-Toolkit を使う</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E3%81%8A%E3%81%BE%E3%81%91-javascript-%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86\">おまけ: JavaScript のメモリ管理</a></p>\n<ul>\n<li><a href=\"#gc-%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E3%81%AF%E5%BF%85%E8%A6%81\">GC があってもメモリ管理は必要</a></li>\n<li><a href=\"#gc-%E4%BB%A5%E5%A4%96%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95-rust\">GC 以外のメモリ管理方法: Rust</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E5%A5%A5%E3%81%8C%E6%B7%B1%E3%81%84\">プログラミングは奥が深い</a></p>\n</li>\n</ul>","frontmatter":{"title":"React と Redux における immutability の重要性、あるいは JavaScript を何も理解してなかった話","date":"March 17, 2021","description":null}},"previous":{"fields":{"slug":"/2021-03-12-dencho/"},"frontmatter":{"title":"電子取引証憑の紙出力による保存が NG になる、税制改正大綱に基づく電子帳簿保存法改正の話"}},"next":{"fields":{"slug":"/2021-04-04-uipath-ipo/"},"frontmatter":{"title":"UiPath が上場するので Form S-1 をさらっと読む"}}},"pageContext":{"id":"97d68a7a-727a-54cd-9246-ae3d919bb8b7","previousPostId":"374b3296-4030-53be-bab2-12e00eb0ca01","nextPostId":"036efa3f-c037-510c-b613-9ef8200c59c8"}},
    "staticQueryHashes": ["1445466728","2841359383"]}