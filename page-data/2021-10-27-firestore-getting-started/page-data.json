{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2021-10-27-firestore-getting-started/",
    "result": {"data":{"site":{"siteMetadata":{"title":"ここにかく"}},"markdownRemark":{"id":"e99b3387-5296-5222-8721-40ab96bc7121","excerpt":"せっかくプログラミングの仕事をしているので、自分でほしいアプリを自分で作ることにした。そのバックエンドとして Firebase を使うことを考えている。理由は3つある。 面倒な認証の実装を Firebase Authentication で省略できるから データの保存先として Cloud Firestore…","html":"<p>せっかくプログラミングの仕事をしているので、自分でほしいアプリを自分で作ることにした。そのバックエンドとして Firebase を使うことを考えている。理由は3つある。</p>\n<ul>\n<li>面倒な認証の実装を Firebase Authentication で省略できるから</li>\n<li>データの保存先として Cloud Firestore が便利そうだから（<a href=\"https://www.youtube.com/watch?v=QcsAb2RR52c\">動画</a>）</li>\n<li>仕事で AWS を使うことがありそうなので、個人では Google Cloud を使ってみたかったから</li>\n</ul>\n<p>アプリの開発には <a href=\"https://expo.dev/\">React Native（Expo）</a> を使うことにする。Expo の公式ドキュメントはとても充実しており、 <a href=\"https://docs.expo.dev/guides/using-firebase/\">Expo アプリから Firebase を使うための初期設定ガイド</a>も親切に用意されている。Expo の話はまた別に書きたい。 React Native ってどう使われてるの？という人は最近開催された <a href=\"https://www.youtube.com/watch?v=OGsR3O4qu6s\">React Native Matsuri 2021 のアーカイブ動画</a>を見るといいと思う。</p>\n<p>React Native の話は置いといて、 Firebase の中心（？）となるデータストアである Firestore について一通り調べてみたので、自分が気になったことを書き留めておいた。</p>\n<h2>初期設定の手順</h2>\n<p>とりあえず動かしてみる。</p>\n<p>まずは Firebase のプロジェクトを作り、 Expo アプリ上で Firebase を使うための初期設定をしてみた。下記の手順で公式ドキュメントを見ながらやれば簡単にできそう。</p>\n<h4>1. ドキュメントを読む</h4>\n<ul>\n<li><a href=\"https://firebase.google.com/docs/firestore/quickstart?hl=ja\">公式の quick start</a> を読む</li>\n<li>先に気になるところをざっと読んで概要を掴んでから試していくとよさそう</li>\n</ul>\n<h4>2. Firebase でプロジェクトを作成する</h4>\n<ul>\n<li><a href=\"https://firebase.google.com/docs/web/setup?hl=ja#create-project\">参考になりそうな公式のドキュメント</a></li>\n<li>Firebase コンソールからでも GCP コンソールからでも作れる</li>\n<li>どっちで作っても中身は同じ（<a href=\"https://firebase.google.com/docs/projects/learn-more?hl=ja\">参考</a>）</li>\n<li>GCP の管理コンソールで API Key を取得できるようになる\n<ul>\n<li>対象のプロジェクトを選んで「API &#x26; Services > Credentials」を見ると、自動生成された Key を取得できる</li>\n<li>auto created by Firebase とか書いてあるはず</li>\n<li>ここから新しく API Key を作ることもできる</li>\n</ul>\n</li>\n</ul>\n<h4>3. 開発用のマシンに Firebase SDK をインストールする</h4>\n<ul>\n<li>普通は <code class=\"language-text\">npm install</code> や <code class=\"language-text\">yarn add</code> でインストールするが、 expo は <code class=\"language-text\">expo install</code> コマンドを使うのがよい</li>\n<li>こうすると、 expo SDK と互換性のあるバージョンをインストールしてくれるので助かる</li>\n</ul>\n<h4>4. Firebase にアプリを追加する</h4>\n<ul>\n<li><a href=\"https://firebase.google.com/docs/web/setup?hl=ja#register-app\">参考になりそうな公式のドキュメント</a></li>\n<li>このとき初期化用のコードが生成されるので後でコピペする</li>\n<li>Firebase SDK を使うためのクラスを定義しておくとよさそう（後述）</li>\n</ul>\n<h4>5. アプリ側で Firebase を initialize する</h4>\n<ul>\n<li>↑ でアプリ作成時に自動生成したコードを使う\n<ul>\n<li>API Key は公開しても良い（<a href=\"https://firebase.google.com/docs/projects/api-keys\">参考</a>）ので、コードに書いてリポジトリにコミットできる</li>\n<li>ただし、<a href=\"https://firebase.google.com/docs/firestore/security/get-started?hl=ja\">セキュリティルール</a>で適切なアクセス制御をしていない場合、 Firestore に対して意図しない不正なアクセスをされる恐れがある</li>\n<li>開発中は特に問題なさそう</li>\n<li>Firebase を initialize するための config、 Auth や Firestore のインスタンスを取得するコードをクラスにまとめておくと便利そう</li>\n</ul>\n</li>\n<li>Cloud Functions やサーバーから Firestore を触る場合は Admin SDK が必要になる\n<ul>\n<li><a href=\"https://firebase.google.com/docs/firestore/quickstart?hl=ja#node.js\">公式の Cloud Firestore スタートガイドの Node.js</a> の箇所を見るのがよさそう</li>\n<li>Admin SDK はセキュリティルールの対象外となる（何でもできる）ので、取り扱いに注意する</li>\n</ul>\n</li>\n</ul>\n<p>今まで Firestore を使った経験はなかったのだが、ドキュメントや記事を読む限りでは普通のデータベースとだいぶ勝手が違っており（例えばスキーマが無い）、将来的に他に移行するのが大変そうという印象がある。</p>\n<h3>Firebase SDK を扱うクライアントのクラス</h3>\n<p>初期設定の 4. で書いたが、 Firebase SDK を扱うクライアント用のクラスを作成しておき、これのインスタンスを使い回すようにするとよさそう（実際は auth とかの実装も必要なはずだが最低限はこれで動く）。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> firebase <span class=\"token keyword\">from</span> <span class=\"token string\">\"firebase/app\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"firebase/firestore\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> firebaseConfig <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../config/dev'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Firebase の apiKey 等の設定を別ファイルに分けておいて import するとよさそう</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Firebase</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> _instance<span class=\"token operator\">:</span> Firebase<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> _store<span class=\"token operator\">:</span> firebase<span class=\"token punctuation\">.</span>firestore<span class=\"token punctuation\">.</span>Firestore<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    firebase<span class=\"token punctuation\">.</span><span class=\"token function\">initializeApp</span><span class=\"token punctuation\">(</span>firebaseConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_store <span class=\"token operator\">=</span> firebase<span class=\"token punctuation\">.</span><span class=\"token function\">firestore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">get</span> <span class=\"token function\">instance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Firebase <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Firebase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_instance<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">get</span> <span class=\"token function\">store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> firebase<span class=\"token punctuation\">.</span>firestore<span class=\"token punctuation\">.</span>Firestore <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_store <span class=\"token operator\">??</span> firebase<span class=\"token punctuation\">.</span><span class=\"token function\">firestore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>これを static メソッドとして、データを Firestore に投稿する際には</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">await</span> Firebase<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">collection</span><span class=\"token punctuation\">(</span><span class=\"token string\">'コレクション名'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doc</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ドキュメント名'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">'フィールド'</span><span class=\"token operator\">:</span> <span class=\"token string\">'値'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'フィールド'</span><span class=\"token operator\">:</span> <span class=\"token string\">'値'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>みたいに呼び出して使うイメージ。これで singleton 的に？インスタンスを使い回すことができる。</p>\n<p>これを使って<a href=\"https://firebase.google.com/docs/firestore/quickstart?hl=ja\">スタートガイド</a>を参考にアプリから適当なデータを Firestore に投稿し、それを別の画面で読み取れるようになった。いろいろメモしたのだが、正直このガイドを見れば十分なので特に書くべきことはなかった。</p>\n<h2>Firestore のデータモデル</h2>\n<p>データモデルは通常の RDB とだいぶ違うので注意が必要。</p>\n<p>Firestore は <code class=\"language-text\">ドキュメント</code> と <code class=\"language-text\">コレクション</code> それから <code class=\"language-text\">リファレンス</code> という3つの概念でデータを管理する。</p>\n<ul>\n<li><code class=\"language-text\">ドキュメント</code>は普通の RDB における「レコード」のようなもので、key と value の組み合わせを格納する\n<ul>\n<li>JSON のように内部でネストして複雑な構造を作ることもできる</li>\n<li>ドキュメント内にコレクションを持つこともでき、これは <code class=\"language-text\">サブコレクション</code> と呼ばれる</li>\n<li>ドキュメントはその key および value としてドキュメントを持つことはできない</li>\n</ul>\n</li>\n<li><code class=\"language-text\">コレクション</code> はドキュメントをまとめた「テーブル」のようなもので、多数のドキュメントを特定の名前（例: users というコレクションでアプリのユーザーに関する user ドキュメントを…）でまとめておくことができる\n<ul>\n<li>完全にスキーマレスで、各ドキュメントは異なるフィールドを持つことができる</li>\n<li>ドキュメントと組み合わせて階層的なデータ構造を作ることができる（<a href=\"https://firebase.google.com/docs/firestore/data-model?hl=ja\">参考</a>）</li>\n<li>コレクションが持てるのはドキュメントのみ</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Reference</code> はドキュメントやコレクションを参照するだけの軽量なオブジェクト\n<ul>\n<li>これを通じてデータの追加や更新、削除を行う</li>\n</ul>\n</li>\n</ul>\n<p>データを初めて追加したときに「暗黙的に」ドキュメントやコレクションが追加されるため、管理コンソール等を通じて明示的に作成する必要はない。</p>\n<h2>Firestore のセキュリティルール</h2>\n<p>実は上記の「暗黙的な追加」はテスト用のデータベースを「セキュリティルール」無しで作ったときの挙動である。</p>\n<p>Firestore の「セキュリティルール」を「ロックモード」にしてデータを追加しようとすると、無効な操作として次のようなエラーを吐く。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Unhandled promise rejection: FirebaseError: Missing or insufficient permissions.]</code></pre></div>\n<p>Firestore ではプロジェクトの追加時にセキュリティルールの開始モードを「テストモード」と「ロックモード」の2種類から選択でき、ロックモードのときは全ての読み書きを拒否する。テストモードでは全ての読み書きを通す。</p>\n<p>ロックモードでプロジェクトを開始し管理コンソールで Firestore のセキュリティルールを見ると、次のようなルールが書かれている。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}</code></pre></div>\n<p>基本的には <code class=\"language-text\">match</code> 式で記述したドキュメントorコレクションへの path に <code class=\"language-text\">allow</code> していく。より詳しい書き方は<a href=\"(https://cloud.google.com/firestore/docs/security/get-started)\">公式ドキュメント</a>を参照。</p>\n<p>5行目の <code class=\"language-text\">if false;</code> を <code class=\"language-text\">if true;</code> にするとテストモードと同じルールになり、全ての読み書きが承認される。これは本番環境では絶対にやってはいけない。また、 <code class=\"language-text\">if false;</code> を <code class=\"language-text\">if request.auth != null;</code> にすると認証を必須にできる。</p>\n<p>なお、アクセス制御だけでなくデータの検証（例えばこのフィールドには 1 以上 5 未満の数字が入る…など）も定義できる。</p>\n<h3>なぜセキュリティルールがあるのか？</h3>\n<p>このセキュリティルールとは、要するにデータの保護ポリシーである。クライアントから送られるデータは信頼できないので、セキュリティルールでデータの機密性と完全性を担保する。</p>\n<p>しかし何故このような仕組みになっているのか。</p>\n<p>Firestore ではサーバーレスで、直接クライアント（SDK）とデータのやり取りをする。通常の Web アプリケーションではクライアントとデータベースの間に Web サーバー的なプロキシがあって、不正なリクエストはそこで弾くような実装をする。つまり、データベースはサーバーの裏に隠されておりユーザーが直接データベースに書き込むことは無い。</p>\n<p>しかし Firestore にはそのレイヤーがなく、 SDK を通じて API を呼び出すために必要な情報は全てアプリにバンドルされている。つまり、セキュリティルールが存在しない場合（アプリから Firestore の操作をする導線が一切なくても）アプリから入手した API Key 等を使って好き勝手に Firestore のデータを読み出したり書き換えることができる。これは非常に危険なので、セキュリティルールを通じてデータのアクセス制御を行う。</p>\n<p>セキュリティルールで実現できることは以下の動画が大変わかりやすい。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=eW5MdE3ZcAw\">Security Rules! 🔑 | Get to know Cloud Firestore #6</a></li>\n</ul>\n<h3>実装の方針</h3>\n<p>ドキュメントや動画を見ることでセキュリティルールが何のために存在するのか、どういう書式で何を書くべきか、どうやってデプロイするかは理解できた。しかし、詳細なルールの設定をする前にアプリ全体でどういうデータを持ち、それらをどのような画面からどのように処理するかを固める必要がありそうなので、実際に適用するセキュリティルールは後で考えることにした。この辺の話は別で書きたい。</p>\n<p>ちなみにサーバーや Cloud Functions から Firestore の操作をするときは普通に IAM を使って権限を制御する（<a href=\"https://cloud.google.com/firestore/docs/security/iam\">参考</a>）。</p>\n<p>Firebase のセキュリティに関しては以下のブログが参考になりそう。</p>\n<ul>\n<li><a href=\"https://flattsecurity.hatenablog.com/entry/2020/04/10/122834\">Firebaseにおけるセキュリティの概要と実践 - Flatt Security Blog</a></li>\n<li><a href=\"https://flattsecurity.hatenablog.com/entry/firestore_security_rules\">Firestoreセキュリティルールの基礎と実践 - セキュアな Firebase活用に向けたアプローチを理解する - Flatt Security Blog</a></li>\n</ul>\n<h2>Firestore のデータ構造を設計する上での注意点</h2>\n<p>通常の RDBMS を用いた Web アプリケーションであれば、データベースに保存するデータは正規化して重複を排除するようなデータ構造にしておき、必要に応じて結合して使う。しかし Firestore でそれを実践しようとすると難しい。</p>\n<p>Firestore には JOIN が無い（！）ので、結合をやろうとすると必要なデータを取得した上でクライアント側で結合する必要がある。不可能ではないが、特定のビューを組み立てるために複数の異なるコレクションからデータを取得するクエリを発行するのは効率が悪い。さらに、クライアント側で複雑なビジネスロジックを記述しなければならないので、作るのも後から修正するのも大変になる。</p>\n<p>そこで、 Firestore（や一般的な NoSQL データベース）では基本的に使う形でそのままデータを保存する。よって、同じデータが複数のドキュメントに重複して存在するような構造になる可能性がある。なお、 Firebase のクエリはデフォルトで shallow な挙動をするので、あるドキュメントにサブコレクションが保持されていても明示的にそれを指定しない限り取得はされない。これは Firebase Realtime Database と Firestore の最大の違いでもある。</p>\n<p>Firestore のデータ構造については以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=v_hR4K4auoQ\">NoSQLデータベースとCloud Firestoreの構造を知ろう| Get to know Cloud Firestore #1</a></li>\n</ul>\n<p>Firestore のクエリには制約がいろいろある。JOIN 以外に驚いたのが <code class=\"language-text\">OR</code> が無いこと。他にもいろいろあるので注意。</p>\n<p><a href=\"https://firebase.google.com/docs/firestore/query-data/queries#query_limitations\">https://firebase.google.com/docs/firestore/query-data/queries#query_limitations</a></p>\n<h3>インデックス</h3>\n<p>Firestore はドキュメントをコレクションに追加したとき、デフォルトで全てのフィールドに対してインデックスを作成する。これにより、ドキュメントやコレクションを横断して特定の条件を満たすフィールドを検索するのが速くなる。</p>\n<p>複数の条件を OR 指定するクエリはない。これを高速に処理するには、 OR 条件を満たすフィールドを追加する。</p>\n<p>複数の条件を AND 指定した場合は「ジグザグマージ結合」が行われる（<a href=\"https://developers-jp.googleblog.com/2019/10/why-is-my-cloud-firestore-query-slow.html\">この記事</a>の理由3を参照）。しかし、この記事にもある通り、これはソートされた複数のインデックスの間を行き来して結果を結合するので、クエリ対象のデータ間に共通点が少なすぎる場合は効率が悪くなってしまう。</p>\n<p>それを改善する手段として「<a href=\"https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#composite_indexes\">複合インデックス</a>」がある。通常のインデックスと違い、 Firestore は自動では複合インデックスを作らないので自分で作る必要がある。なぜデフォルトではないかというと、複合インデックスは全ての場合でクエリのパフォーマンス向上につながるとは限らないかららしい。</p>\n<p>効率的なクエリやインデックスの詳しい話は以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=Ofux_4c94FI\">How do queries work in Cloud Firestore? | Get to know Cloud Firestore #2</a></li>\n</ul>\n<h3>課金 - Pricing</h3>\n<p>Firestore は <a href=\"https://cloud.google.com/firestore/pricing\">Read/Write/Delete クエリの実行回数に応じて課金される</a>ので、効率の良いクエリは節約につながる。料金の計算にはいろいろ注意が必要…</p>\n<ul>\n<li><code class=\"language-text\">Read</code>: 検索対象のボリュームによらず、クライアントに返すドキュメントが1つであれば1回、ドキュメントが20個であれば20回分の料金になる\n<ul>\n<li>つまり、ページネーションを実装する等して「必要ないデータを取得しないこと」が非常に重要</li>\n<li>クエリの結果をクライアントでリッスンする場合、結果セット内のドキュメントが追加または更新されるたびに Read として課金される</li>\n<li>セキュリティルールでドキュメントの読み取りが発生する場合、それも Read として課金される</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Write</code>: あるドキュメントのある1箇所のフィールドを更新するのも同じドキュメント内で30箇所のフィールドを更新するのも同じ料金になる</li>\n<li><code class=\"language-text\">Delete</code>: 削除したドキュメント数に比例する</li>\n</ul>\n<p>このようなルールは、作るアプリによっては実装に大きな影響を与える可能性がある。</p>\n<p>例えば LINE のようなチャットアプリで5秒に1度ルームにメッセージを送ることを考えると、参加者が2人なら1分あたり <code class=\"language-text\">2 * 60/5 = 24</code> 回の書き込みと <code class=\"language-text\">2 * 24 = 48</code> 回の読み込みが発生する。しかし、これが n 人なら <code class=\"language-text\">n * 60/5 = 12n</code> 回の書き込みと <code class=\"language-text\">n * 12n = 12 * n^2</code> 回の読み込みが発生する。つまり、指数関数的に課金額が増加していく。</p>\n<p>このようなケースでは書き込みの度に読み込ませるのではなく、 Cloud Functions で一定間隔ごとにメッセージを一括更新しまとめて読み込ませるのがよさそうだ。</p>\n<p>課金額を抑える方法については以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=6NegFl9p_sE\">Cloud Firestore Pricing | Get to know Cloud Firestore #3</a></li>\n</ul>\n<p>これは結構注意していても課金で爆死する匂いがするので Budget や Alert 的な閾値を設定しておいた方がよさそう。</p>\n<p><a href=\"https://firebase.google.com/docs/firestore/monitor-usage\">https://firebase.google.com/docs/firestore/monitor-usage</a></p>\n<h2>ドキュメントの制約</h2>\n<p>Firestore のドキュメントには様々な制約がある。</p>\n<ul>\n<li>1つのドキュメントには 1MB までしか入れられず、インデックスの数は 40,000 まで\n<ul>\n<li>このような制限が設けられている理由は、 Firestore がデータの追加時に全てのフィールドに対してインデックスを作るから</li>\n<li>ドキュメントの更新時にはインデックスを再構築するため、多すぎるフィールドは Write のパフォーマンスに悪影響をもたらす</li>\n</ul>\n</li>\n<li>同じドキュメントに対して Write できるのは1秒に1回のみ</li>\n<li>ドキュメントの取得時にはそのドキュメントの全てのフィールドを取得し、一部分だけを取得することはできない\n<ul>\n<li>Firestore のクエリのパフォーマンスは対象となるデータセットのサイズではなく結果セットのサイズに比例する</li>\n<li>つまり、この点でも一つのドキュメントに必要以上のデータを詰め込むことは得策ではない</li>\n</ul>\n</li>\n<li>Firestore のクエリは shallow で、明示的に指定したドキュメントのみを取得しそのサブコレクションは取得しない\n<ul>\n<li>つまり、一緒に使うデータはサブコレクションに分けるのではなく同じドキュメントに詰めるのがよい</li>\n</ul>\n</li>\n<li>Array の特定の位置に要素を挿入、更新、削除することはできない\n<ul>\n<li>Array 内の要素を追加するには arrayUnion()、削除するには arrayRemove() を使う</li>\n</ul>\n</li>\n</ul>\n<p>ドキュメントの構造や制約については以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=o7d5Zeic63s\">Maps, Arrays and Subcollections, Oh My! | Get to know Cloud Firestore #4</a></li>\n</ul>\n<h3>ドキュメント設計の工夫</h3>\n<p>これらの制約や Firestore の特性から、 Firestore のドキュメント - コレクションのデータ構造設計は多少の工夫が必要になる。</p>\n<p>例えば特定の画面を構成するのに必要で読み込みの頻度が多く書き込みの頻度が少ないデータは非正規化して持ち、 Cloud Functions 等でまとめて更新して整合性を保つ。</p>\n<p>階層的な関係にあるデータであっても、それが異なるドキュメント間で N:N の関係にあるのであれば、それぞれとそのマッピング（例: Users, Restaurants, FavoriteRestaurants）をトップレベルのコレクションとして持つのがよい。</p>\n<p>データ構造の工夫については以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=haMOUb3KVSo\">How to Structure Your Data | Get to know Cloud Firestore #5</a></li>\n</ul>\n<p>非正規化したデータの更新には Cloud Functions を使う。使い方については以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=rERRuBjxJ80\">How do Cloud Functions work? | Get to know Cloud Firestore #11</a></li>\n</ul>\n<h3>ページネーション</h3>\n<p>Firestore ではドキュメントの取得回数に応じて課金されるので、ページネーションが重要になる。また、ユーザー体験的にも必要な分だけ取得できたほうがよい。最後のドキュメントを previousDoc として次のクエリで <code class=\"language-text\">.start(after: previousDoc)</code> 的な使い方が多そう。</p>\n<p>以下の動画にだいたい説明されている。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=poqTHxtDXwU\">How Do I Paginate My Data? | Get to know Cloud Firestore #7</a></li>\n</ul>\n<h2>トランザクション</h2>\n<p>Firestore では、「全ての操作が成功する」か「いずれも適用されない」という操作を行うための atomic な処理が2種類用意されている。</p>\n<ul>\n<li><code class=\"language-text\">Transaction</code>: 1つまたは複数のドキュメントに対する読み取りと書き込みの操作</li>\n<li><code class=\"language-text\">Batch Write</code>: 1つまたは複数のドキュメントに対する一連の書き込み操作</li>\n</ul>\n<p>Batch Write の利点は、読み取りができない代わりに読み取り起因の失敗がないこと、全てのクライアントがオフラインでも実行できることがある。</p>\n<p>両者には幾つかの注意点がある。</p>\n<ol>\n<li><strong>Reads Before Write</strong>: 書く前に読む</li>\n<li><strong>No Side Effects</strong>: retry の可能性があるので、副作用をトランザクション内で実行しない</li>\n<li><strong>Don’t Go Overboard</strong>: 関係ないドキュメントをトランザクション内に入れない（ロックによるパフォーマンス低下など、デメリットしかない）</li>\n<li><strong>No Offline Support</strong>: トランザクションはクライアントがオフライン状態のとき必ず失敗する</li>\n<li><strong>500 Documents</strong>: 1トランザクションで処理できるドキュメントの上限数は 500</li>\n</ol>\n<p>5 の制限により、 500 を超える数のドキュメントを一つの Transaction/Batch Write で更新することはできず、複数回に分けて実行することになる。トランザクションについては以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=dOVSr0OsAoU\">How do Transactions Work? | Get to know Cloud Firestore #8</a></li>\n</ul>\n<h2>オフラインサポート</h2>\n<p>Firestore にはオフラインサポートという機能がある。端末がインターネットから切断しても、オフラインでキャッシュを保持してそれをいい感じに Firestore に反映してくれる。オフラインキャッシュは無制限ではなく（とはいえ通常の使用では気にしなくてもいいサイズらしい）、最も使われていないデータから消されていく。</p>\n<p>ちなみに、 Firestore にはインデックスがあるがキャッシュにはそれが無いので、巨大なデータをクライアント側のキャッシュで扱うのは得策ではない。小さなデータで変更の頻度が少なければオフラインに持っておくことで節約になるかもしれないが、ほとんどのケースではそのような使い方はユーザー体験の悪化を招きそうだ。</p>\n<p>なお、オフラインサポートは iOS/Android ではデフォルトで有効だが、 Web では少しだけコードを書く必要がある。オフラインサポートについては以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=oDvdAFP6OhQ\">How do I Enable Offline Support? | Get to know Cloud Firestore #9</a></li>\n</ul>\n<h2>リアルタイムリスナー</h2>\n<p>Firestore には「リアルタイムリスナー」と呼ばれる仕組みがあり、ドキュメントに対する変更を検知することができる。</p>\n<p>これによって明示的に fetch しなくても新しいデータを取得できユーザー体験が格段によくなるため、特に理由がなければこれを使うべきだろう。しかし、以下の点に注意する必要がある。</p>\n<ul>\n<li>必要以上のデータをダウンロードしない（その分課金されるので）\n<ul>\n<li>ドキュメントを適切に設計する\n<ul>\n<li>サブコレクションに入れておくなど</li>\n</ul>\n</li>\n<li>必要ないときはリスナーを deactivate する\n<ul>\n<li>例えば、コンポーネントを生成時に listen するならコンポーネントがなくなるときに切る</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>リアルタイムリスナーは\bバックグラウンドで動作しない\n<ul>\n<li>つまり、ユーザーが戻ってきたときは多少のロードが必要になる</li>\n</ul>\n</li>\n</ul>\n<p>リアルタイムリスナーについては以下の動画が参考になる。</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=3aoxOtMM2rc\">リアルタイムを使うかどうか | Cloud Firestore を知ろう＃10</a></li>\n</ul>\n<h2>Firestore のデータ設計まとめ</h2>\n<p>まとめると、 Firestore は以下の点に注意して使う必要がありそうだ。</p>\n<h3>画面にそのまま使えるような構造にデータをモデリングする</h3>\n<ul>\n<li>Firestore にはクライアントから直接アクセスする、かつ JOIN が無い\n<ul>\n<li>つまり、画面を組み立てるのにデータの加工が必要な場合はクライアント側でしなければならない</li>\n<li>さらに、データが複数のドキュメントに分かれていると複数回のクエリが必要になる</li>\n<li>データの重複を許容して非正規化し画面ごとにドキュメントを用意することで、パフォーマンスが上がり課金額は下がる</li>\n</ul>\n</li>\n<li>全てのケースで非正規化が有効というわけではない\n<ul>\n<li>時間の経過やアプリの利用とともにデータが増えていく場合、後述の Cloud Functions による更新が難しくなっていく</li>\n<li>このような場合では、\n<ul>\n<li>ドキュメント間の関係性を表現する「リファレンス型」をドキュメントのフィールドとして持つことで JOIN っぽいドキュメント取得を行う\n<ul>\n<li>Read が増えるので万能ではない</li>\n</ul>\n</li>\n<li>更新の頻度を抑えるような仕様をアプリに追加する</li>\n<li>一定期間を過ぎたデータをクライアントから取得できないようにする</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>1:1 の関係性を表現する場合は、同一の id をドキュメントに割り当てる</li>\n<li>1:n の場合は…以下のいずれかを行う\n<ul>\n<li>ドキュメントのサブコレクション、もしくは<a href=\"https://firebase.google.com/docs/firestore/query-data/queries?hl=ja#collection-group-query\">コレクショングループ（同じ id を持つコレクション）</a>として持つ</li>\n<li>リファレンス型を持つフィールドを用意する</li>\n<li>ドキュメント内のフィールドで非正規化して持つ</li>\n</ul>\n</li>\n</ul>\n<h3>ドキュメントは大きくしすぎない</h3>\n<ul>\n<li>Firestore ではデータをドキュメント単位で取得し、ドキュメント内の一部のフィールドのみを取得するような操作ができないため</li>\n<li>フィールド数が増えるとその分だけスキーマやデータの検証も複雑になる</li>\n<li>ドキュメントには保持できるサイズ（1MB）、フィールドの数（40,000）に制約がある\n<ul>\n<li><a href=\"https://firebase.google.com/docs/firestore/quotas?hl=ja\">他にも様々な制約がある</a></li>\n</ul>\n</li>\n<li>増え続けるデータはサブコレクションに隔離する</li>\n<li>「画面にそのまま使えるような設計」とは対立する可能性がある\n<ul>\n<li>CQRS 的に（？）読み取り用のドキュメントと書き込み用のドキュメントを分離するのもいいかもしれない\n<ul>\n<li>この場合、副次的なメリットもある\n<ul>\n<li>セキュリティルールの記述が簡潔になる</li>\n<li>書き込みの履歴を残すことができる</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>読み取りと書き込みを分離するデメリットとして、書き込み用ドキュメントの更新をトリガーにして Cloud Functions で読み取り用のドキュメントを更新することで整合性を保つ必要がある</li>\n</ul>\n</li>\n</ul>\n<h3>非正規化されたデータを一斉に更新する際は Cloud Functions を使う</h3>\n<ul>\n<li>以下の点に注意する\n<ul>\n<li>セキュリティルールの対象外となるので、 Firestore のセキュリティルールで設定したスキーマやデータの検証をすり抜ける可能性がある</li>\n<li>1トランザクションで更新できるドキュメント数には 500 までという制限がある</li>\n<li>更新中はドキュメントをロックするのでパフォーマンスが落ちる</li>\n</ul>\n</li>\n</ul>\n<h3>ドキュメント内で access level が異なる情報を保持してはならない</h3>\n<ul>\n<li>住所や支払情報など</li>\n<li>Firestore ではデータの検証やアクセスレベルの管理には必ずセキュリティルールを使う</li>\n<li>セキュリティルールはドキュメント単位で設定される</li>\n<li>また、ドキュメントの一部取得を担保することは不可能（表示上は一部しか使わなくとも、クエリとしては完全なドキュメントを取得している</li>\n<li>ドキュメントを分け、必要ならリファレンスとして持つ\n<ul>\n<li>リファレンスはセキュリティルールで保護できるので access level が異なってもよい</li>\n</ul>\n</li>\n</ul>\n<h2>最後に</h2>\n<p>まだ何もやってないけど実際にアプリを開発し始めたら無限に気になることがありそう。</p>\n<p>進んだら続きを書きたい。</p>","frontmatter":{"title":"Firestore を使いたいので調べたことを記録する自分用の記事","date":"October 27, 2021","description":null}},"previous":{"fields":{"slug":"/2021-09-26-gitlab-ipo/"},"frontmatter":{"title":"GitLab が上場するので Form S-1 を読んだ話"}},"next":{"fields":{"slug":"/2021-11-06-hashicorp-ipo/"},"frontmatter":{"title":"HashiCorp が上場するので Form S-1 を読んだ話"}}},"pageContext":{"id":"e99b3387-5296-5222-8721-40ab96bc7121","previousPostId":"97b04570-6701-58bc-a76c-ed3f2a7ebecd","nextPostId":"2a50f996-6528-5467-9912-b2d7db191343"}},
    "staticQueryHashes": ["2841359383","3257411868"]}