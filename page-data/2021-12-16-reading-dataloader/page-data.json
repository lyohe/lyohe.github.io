{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2021-12-16-reading-dataloader/",
    "result": {"data":{"site":{"siteMetadata":{"title":"ここにかく"}},"markdownRemark":{"id":"78d2df38-a6ac-5ddd-950c-b9f96daff7f6","excerpt":"graphql/dataloader のドキュメント及びソースコードを全て読んだので、その話を書く。 読むことにした第一の理由は仕事で使うからだが、以下の特徴から自分のプログラミング学習教材として適していそうだと考えたからでもある。 広く使われている OSS である GitHub の星が 11k npm trends…","html":"<p><a href=\"https://github.com/graphql/dataloader\">graphql/dataloader</a> のドキュメント及びソースコードを全て読んだので、その話を書く。</p>\n<p>読むことにした第一の理由は仕事で使うからだが、以下の特徴から自分のプログラミング学習教材として適していそうだと考えたからでもある。</p>\n<ul>\n<li><strong>広く使われている OSS である</strong>\n<ul>\n<li>GitHub の星が 11k</li>\n<li><a href=\"https://www.npmtrends.com/\">npm trends</a> で検索しても多くの人がダウンロードしている</li>\n</ul>\n</li>\n<li><strong>コードの量が少ない</strong>\n<ul>\n<li>実装は src/index.js に全て書かれている</li>\n<li>コメント含めて500行にも満たず、しかもその 1/3 くらいはコメント</li>\n</ul>\n</li>\n<li><strong>テストカバレッジが高い</strong>\n<ul>\n<li>常に 100%</li>\n<li>初めて読むコードでテストカバレッジが高いと、テストコードを読むことで期待される挙動を確認できるので嬉しい</li>\n</ul>\n</li>\n</ul>\n<p>npm trends によると、一週間で200万件近くダウンロードされているようだ。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1229ea06bd48b738b680293befb15093/b1001/dataloader-npm-trends.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.68354430379746%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgElEQVQ4y42U3U7DMAyF+/5Px/2Q0K6QWDvW5t92cpCdtnSCDSJZSZT6s3Nid5hdxDzPZsyMZ6O19qcN0zThfD7jcrkADRCpqLXbthYRm/8zhlwKnHNmKSXLcjMiNti2f5aZBrQMb6Hg/erhszqro4APEDIwGXhzfGQG9D5gHCeEEJFzhneqZVmdmwqn6vXpmb6rDaUU5JwsAzMmtDWajkgNN59RhQ366ModBwwb6P41sX8ktaGwXrc+BX1GQaKKgVeNHkber/z7mUKuQcw0+AH4vzqrhyAuCy6eEct3Se3AXdqDw6979McKpeJtKuDa7oreNCxEYGlgqSCpP2a1zBVLEtyiYPSMJQsK97O7TlF6Jrb0fRG4xFgiwes+C7ROl8imVSFBSNTLSR9MO8i66AAM3oP3Kx+r6u/RfvS6th4xQiqm49a3GimmhF6j2dZ6viyLzdqiIQTrJP0XjC6uWmqG1DDOAd4tBlOIAtMKVKdtVsgWpK8Jr6cTXs4fSNKBX+i2nqRwdv0yAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dataloader-npm-trends\"\n        title=\"dataloader-npm-trends\"\n        src=\"/static/1229ea06bd48b738b680293befb15093/f058b/dataloader-npm-trends.png\"\n        srcset=\"/static/1229ea06bd48b738b680293befb15093/c26ae/dataloader-npm-trends.png 158w,\n/static/1229ea06bd48b738b680293befb15093/6bdcf/dataloader-npm-trends.png 315w,\n/static/1229ea06bd48b738b680293befb15093/f058b/dataloader-npm-trends.png 630w,\n/static/1229ea06bd48b738b680293befb15093/40601/dataloader-npm-trends.png 945w,\n/static/1229ea06bd48b738b680293befb15093/78612/dataloader-npm-trends.png 1260w,\n/static/1229ea06bd48b738b680293befb15093/b1001/dataloader-npm-trends.png 1380w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>graphql/dataloader とは</h2>\n<p><a href=\"https://github.com/graphql/dataloader\">graphql/dataloader</a> はアプリケーションのデータ取得に使用される汎用的なユーティリティであり、データソースからのデータ取得を Batch 処理したり結果を Cache するための簡単な API を提供する。これにより、データ取得リクエストを大幅に効率化することができる。</p>\n<p>元のアイデアは Facebook （現 Meta）社内で2010年に開発された “Loader” API で、これは当時存在していた様々な KVS の back-end API からデータを取得する方法を統一するために開発された。この “Loader” API を簡略化し Node.js アプリケーション等で使えるよう JavaScript で実装したのが graphql/dataloader で、現在は GraphQL Foundation によって MIT ライセンスで公開されている。</p>\n<p>アイデアとしては Facebook の Production 環境で使われている仕組みと同じだが、このリポジトリのコードはあくまで参考実装であり Facebook で使われているわけではない。当時 Facebook では PHP で同様の機構が実装されていたようだ。</p>\n<p>主に GraphQL サービスの構築に使われているが、特定のアーキテクチャやデータソースに依存するような実装にはなっていない。なお、GraphQL サービスのパフォーマンスを向上させるためには何かしら同じような仕組みが必要になる（詳しくは後述）ので、JavaScript に限らず様々な言語で様々な実装がされている。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>ちなみに graphql/dataloader を最初に書いた Lee Byron と Dan Schafer は Facebook 社で GraphQL を開発したメンバーでもある。</p>\n<h2>主要な機能</h2>\n<p><a href=\"https://github.com/graphql/dataloader/blob/master/README.md\">README</a> を読むと、 graphql/dataloader には <code class=\"language-text\">Batch</code> と <code class=\"language-text\">Cache</code> の2つの機能があることが分かる。</p>\n<h3><a href=\"https://github.com/graphql/dataloader#batching\">Batch</a></h3>\n<p>データ取得のリクエストを一定時間待ち、その間に行われたリクエストを統合して Batch 処理する。</p>\n<p>使う側は <a href=\"https://github.com/graphql/dataloader#batch-function\">Batch Function</a> と呼ばれる関数を自身で定義して DataLoader のコンストラクタへ渡す。この関数は <strong>Batch 処理対象となる key の配列を受け取り、その key と対応する value（もしくは Error）の配列の Promise を返す</strong>ようにしておく。つまり…</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">BatchFunction<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token punctuation\">(</span>keys<span class=\"token operator\">:</span> $ReadOnlyArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>$ReadOnlyArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span> <span class=\"token operator\">|</span> Error<span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>実際に Batch Function をどのように定義するかは、リポジトリの <a href=\"https://github.com/graphql/dataloader/blob/master/examples/SQL.md\">examples/SQL.md</a> が分かりやすいかもしれない。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> DataLoader <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dataloader'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> sqlite3 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sqlite3'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">sqlite3<span class=\"token punctuation\">.</span>Database</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./to/your/db.sql'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Dispatch a WHERE-IN query, ensuring response has rows in correct order.</span>\n<span class=\"token keyword\">const</span> userLoader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataLoader</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ids</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  db<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SELECT * FROM users WHERE id IN $ids'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>$ids<span class=\"token operator\">:</span> ids<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">error<span class=\"token punctuation\">,</span> rows</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ids<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>\n        <span class=\"token parameter\">id</span> <span class=\"token operator\">=></span> rows<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">row</span> <span class=\"token operator\">=></span> row<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> id<span class=\"token punctuation\">)</span>\n          <span class=\"token operator\">||</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Row not found: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Usage</span>\n\n<span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> userLoader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1234'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> promise2 <span class=\"token operator\">=</span> userLoader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token string\">'5678'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span> user1<span class=\"token punctuation\">,</span> user2 <span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise1<span class=\"token punctuation\">,</span> promise2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user1<span class=\"token punctuation\">,</span> user2<span class=\"token punctuation\">)</span></code></pre></div>\n<p>上記の <code class=\"language-text\">ids => new Promise((resolve, reject) => { db.all(...) }</code> が Batch Function であり、何のことはない key の配列を受け取って value もしくは Error の配列（の Promise）を返すだけの関数である。</p>\n<p><code class=\"language-text\">DataLoader.load</code> に取得対象の key を渡して呼び出すと、 <a href=\"https://github.com/graphql/dataloader#batch-scheduling\">Batch Scheduling</a> 内（デフォルトはイベントループ内の 1 tick。詳しくは後述）に行われたデータ取得リクエストの key を集めた配列を引数に Batch Function を呼び出し、結果として key に対応する value の配列の Promise を返す。</p>\n<p>「Batch Function は key 配列を受け取って value の配列の Promise を返す」が「<code class=\"language-text\">DataLoader.load</code> では単一の key を取りそれと対応する value の Promise を返す」という構造が肝で、ユーザー側としては key を渡して load するだけで裏側で DataLoader が一定時間分の key をまとめて Batch Function に配列として渡し、まとめてデータベースにリクエストを送ってくれる。</p>\n<p>この <code class=\"language-text\">DataLoader.load</code> はアプリケーションの複数の箇所から呼び出される可能性があるが、同一の DataLoader インスタンスからの load であれば Batch 処理（と結果の Cache が）できる。</p>\n<p>GraphQL の Resolver ではこれが非常に重要で、 DataLoader を使うと簡単に非同期 Resolver による N+1 問題を回避することができる。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>DataLoader の Batch 処理を簡単に図解すると、次のようになる。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e68f13b146e25a746f3994e141d57b40/669eb/dataloader-batchloadfn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.43037974683544%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkUlEQVQoz3VSi47iMAzs///aVbDQA7E6QAJKSULV0qTpO5mVvc2qi3SW3LESd+yxE3V9j6ZtYZuWcRhHeO8xOcc+ThOj8x7OOb4jm6YJ4zjyGWHf9xxHNs9hlMIry2DyHFoptFUFLSX088lopATnSYm2LJmwer2QZRnyPGcvy5KLRPAe3jkYrXG9XnFPU0YpBPquQ7jnzmanuG1bJpRScnfBIvr4WcIwDOyUTPhu4ywzSOy6jp1yw3nk54rvJoTAfr/H4XBgvN/vXJQbWORrrVluXdffksNlIPbz8G+3G+I/MbbbLVarFdI0/SEMRrmXy4WRCiqlviVTIjkRBV/+9G5LVcfjEU3TMCEthwlJO83NWsszoZiQipAk6oJkbzYbXhgtg85IZlVVjPQPzfWH8PF44HQ6cTI5VTTGoCgKJEmCv7sd4jjGer3G+XzG+uOD57xU+GuGYcthWxSTdFvX2CUJ/n1+QgmBp1L8xAh1VfGTwmIs0f/mFMwNAww9+jRFXxQYjcHUNJhoq9bCCsE5gecLCttQ8DDNd2oAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dataloader-batchloadfn\"\n        title=\"dataloader-batchloadfn\"\n        src=\"/static/e68f13b146e25a746f3994e141d57b40/f058b/dataloader-batchloadfn.png\"\n        srcset=\"/static/e68f13b146e25a746f3994e141d57b40/c26ae/dataloader-batchloadfn.png 158w,\n/static/e68f13b146e25a746f3994e141d57b40/6bdcf/dataloader-batchloadfn.png 315w,\n/static/e68f13b146e25a746f3994e141d57b40/f058b/dataloader-batchloadfn.png 630w,\n/static/e68f13b146e25a746f3994e141d57b40/40601/dataloader-batchloadfn.png 945w,\n/static/e68f13b146e25a746f3994e141d57b40/669eb/dataloader-batchloadfn.png 1244w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>Batch の実行範囲</h4>\n<p><code class=\"language-text\">DateLoader.load(key)</code> はデフォルト 1 tick ごとに key を配列にまとめ Batch Function を呼ぶ。</p>\n<p>ここで 1 tick とはどういう意味か。graphql/dataloader は Batch Scheduling に Node.js の <a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick\">process.nextTick()</a> を使っており、これに渡したコールバックは呼び出し時点のイベントループ内の phase に関わらず次の phase、つまり C/C++ ハンドラが JavaScript を実行するタイミング、の前に実行される。</p>\n<p>具体的には、下図のそれぞれの箱の中で process.nextTick() にコールバックを渡すと、各箱に固有の処理が行われたあと次の箱に進む前にそれが呼ばれる。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/638e9d046f1a25e64765683d9e58ff99/5b4a1/event-loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.62025316455697%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwUlEQVQ4y32UaVPbMBCG/aFluApMSSjEdnzl8O0cjmUpDtChnWn//w96O7uKiZsYPjyzh8avdqW1jNuBDSdI4AQp3EnGvuVGGI3ncIMU3jSD5Yacs70Ith/D9mKYTsiW1vxZjodRgK+X9zBu7k1YfggrCOFME9iTGKY/x8ifw55EDMWM1xJ2/DnsIMLjeILzbw8wBiMPxVYhFQLFi0S+rZEJgbTqoRRIyopJ9yTrivPRssTV3SOMgekhl5IFc1UjkzWyumM7sOC6OoHy4aLEZVdw8aaw/tsweSORteIdWkGyJxUeC1KrxY6s5ErzTwT7KvxfsNaCy99bFk03nTOjD9p488HZbo4ECyWRNzWKF/VeKbH4qd434QoroXO/tp8LUoV06Nzm3hIs+qp0XugPi2e9Wbf93pZJiCrkGxXiMDobcYjJb89UtPRVqCQyavVVt8w3fIys9Qyu9rSXsmrHZq0Fh6aP5a7h4V69NSj/7LDYKRS1ZPI97Ff9FEKyOA/27dCGF6VwifiAEyZwooTzXpzpeJZgPI1PoLwVRLi4+QHj/HrIP/rYT/hx0Dblh+DJnrHfrhOU+3LxnR+CY86uBvgHugGnmJCSsr4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"event-loop\"\n        title=\"event-loop\"\n        src=\"/static/638e9d046f1a25e64765683d9e58ff99/f058b/event-loop.png\"\n        srcset=\"/static/638e9d046f1a25e64765683d9e58ff99/c26ae/event-loop.png 158w,\n/static/638e9d046f1a25e64765683d9e58ff99/6bdcf/event-loop.png 315w,\n/static/638e9d046f1a25e64765683d9e58ff99/f058b/event-loop.png 630w,\n/static/638e9d046f1a25e64765683d9e58ff99/5b4a1/event-loop.png 831w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>上図は <a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained\">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained</a> から引用。</p>\n<p>Batch が実行されるタイミングを自分で決めたい（例えば 16ms 後に実行する、とか）場合は <code class=\"language-text\">batchScheduleFn</code> を定義して DataLoader のコンストラクタに渡せばよい。詳しくは README の <a href=\"https://github.com/graphql/dataloader#batch-scheduling\">Batch Scheduling</a> を参照。</p>\n<h3><a href=\"https://github.com/graphql/dataloader#caching\">Cache</a></h3>\n<p>Batch と並ぶ graphql/dataloader の主要な機能として Cache がある。</p>\n<p>これは <strong>Batch に登録される key とそれに対応する value の Promise の組をメモ化</strong>する。</p>\n<p>これにより、同一の DataLoader インスタンスから実行された（≒ 同一のリクエストにおける） Batch 内で同一の key で複数回 value を取得しようとするとき、二回目以降のデータ取得リクエストには Cache から value の Promise を返すことができるようになる。これにより、データ取得のパフォーマンスが大きく向上する。</p>\n<p>Cache はデフォルトで es6 から追加された <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a> を使う。Cache 内の key と value の組み合わせは load する度に無限に増えていくので、 DataLoader インスタンスの寿命が長い場合はメモリを大量に消費する可能性があり安全ではない。</p>\n<p>ただし、 DataLoader インスタンスは原則的にリクエスト単位で作られるので、クライアントにレスポンスを返した後は DataLoader インスタンスへの参照がなくなり GC によってメモリが解放されるので、問題が起きる可能性は少ない。</p>\n<p>リクエスト毎に DataLoader インスタンスを作る理由は Cache を適切に扱うためで、<strong>仮にリクエスト間でこれを共有すると異なるリクエストのデータ取得結果が Cache としてそれぞれのクライアントから見えてしまい</strong>適切ではない。これは DataLoader を使うにあたって非常に重要な点で、例えば GraphQL と合わせて使う場合はリクエスト毎の context に attach することになると考えられる。</p>\n<p>以上の背景から、もし Cache の生存期間を長くしたい場合はカスタムの Cache をクライアントごとに生成することを検討すべきだろう。その場合は DataLoader のコンストラクタで <code class=\"language-text\">cacheMap</code> として自分が使いたい Cache のインスタンスを渡せばよい。詳しくは README の <a href=\"https://github.com/graphql/dataloader#custom-cache\">Custom Cache</a> を参照。</p>\n<p>Cache の key は通常 string 等のスカラ値だが、オブジェクトを使うことも許容されている。その場合は Cache の key となるオブジェクトから実際に key と value （の Promise）の組を取り出す関数である <code class=\"language-text\">cacheKeyFn</code> を定義して DataLoader のコンストラクタに渡す必要がある。このとき、DataLoader は <code class=\"language-text\">cacheKeyFn</code> の返り値を Cache とみなす。</p>\n<h2>Why <a href=\"https://github.com/graphql/dataloader#using-with-graphql\">Using with GraphQL</a></h2>\n<p>DataLoader は GraphQL サービスの構築によく使われる。この理由は GraphQL のドキュメントをよく読んでいくと分かる。</p>\n<p><a href=\"https://graphql.org/learn/\">https://graphql.org/learn/</a></p>\n<p>GraphQL のクエリにおける各フィールドの値は、 Resolver と呼ばれる関数によって取得される。フィールドに文字列や数値などスカラ値が生成される場合は実行が完了し、オブジェクトが生成される場合はそのオブジェクトに含まれるフィールドを更に　Resolve し、これをスカラ値に達するまで続ける。つまり GraphQL のクエリは必ずスカラ値に到達する。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p>Resolver がデータベースを読み書きする場合、これは通常 Promise を返す非同期関数となる。GraphQL はフィールドに値が生成されることを期待しており、非同期 Resolver が完了するのを待ってから「optimal concurrency」で処理を続行する。<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<blockquote>\n<p>During execution, GraphQL will wait for Promises, Futures, and Tasks to complete before continuing and will do so with optimal concurrency.</p>\n</blockquote>\n<p>ここで　Resolver が Promise の配列を返すとき、 GraphQL は全ての Promise を並行して（concurrently）待つ。</p>\n<p>それに加え、フィールドがオブジェクトの配列である場合、オブジェクトの各フィールドを解決するために処理を続行する。つまり、配列でオブジェクトを返すときはその配列要素ごとに Resolver が実行される。<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup></p>\n<p>つまり、これらの仕様を無視して素朴に GraphQL サービスを構築すると、フィールドが解決される度に新しいデータベースへのリクエストが発生してしまい、いわゆる N+1 問題が起きる。</p>\n<p>文章だけだと分かりにくいので具体例を用意した。例えば、次のような GraphQL スキーマがあると仮定する。</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 顧客</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Customer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n  <span class=\"token attr-name\">orders</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Order</span><span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># 顧客による注文</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Order</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n  <span class=\"token attr-name\">items</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Item</span><span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">amount</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># 注文される商品</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Item</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n  <span class=\"token attr-name\">description</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n  <span class=\"token attr-name\">price</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">customer</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Customer</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>このときある id を持つ顧客の注文一覧とそれぞれで注文された商品を取得するクエリは次のようになるだろう。</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span> <span class=\"token definition-query function\">GetOrdersAndItems</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query\">customer</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> '<span class=\"token property\">foobar</span>'<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">id</span>\n    <span class=\"token object\">orders</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token object\">items</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">name</span>\n        <span class=\"token property\">description</span>\n        <span class=\"token property\">price</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token property\">amount</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>GraphQL の各 Resolver が非同期かつ DataLoader を使わず個別に SQL データベースから注文や商品を取得するような実装になっている場合、次のような SQL が発行されると考えられる（あくまで例です）。</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 1. 顧客 id を使って注文を探す</span>\n<span class=\"token keyword\">SELECT</span> item_id<span class=\"token punctuation\">,</span> amount <span class=\"token keyword\">FROM</span> orders <span class=\"token keyword\">WHERE</span> customer_id <span class=\"token operator\">=</span> <span class=\"token string\">\"foobar\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 2. 1 の結果として得た item_id から各商品を探す</span>\n<span class=\"token keyword\">SELECT</span> name<span class=\"token punctuation\">,</span> description<span class=\"token punctuation\">,</span> price <span class=\"token keyword\">FROM</span> items <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token string\">\"hoge\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> name<span class=\"token punctuation\">,</span> description<span class=\"token punctuation\">,</span> price <span class=\"token keyword\">FROM</span> items <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token string\">\"fuga\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> name<span class=\"token punctuation\">,</span> description<span class=\"token punctuation\">,</span> price <span class=\"token keyword\">FROM</span> items <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token string\">\"piyo\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 以下、2 が注文された商品数だけ実行される</span></code></pre></div>\n<p>これに対して DataLoader が提供する Batch や Cache の API を介してデータを取得するとデータベースのアクセスを大幅に減らすことができ、計算資源の節約やパフォーマンスの向上に繋がる。例えば上記の 2. であれば、</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 2. 1 の結果として得た item_id から各商品を探す</span>\n<span class=\"token keyword\">SELECT</span>\n  name<span class=\"token punctuation\">,</span> description<span class=\"token punctuation\">,</span> price\n<span class=\"token keyword\">FROM</span>\n  items\n<span class=\"token keyword\">WHERE</span>\n  id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"hoge\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"fuga\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"piyo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>のようなクエリが一回だけ発行される（上記はあくまで例であり、実際にどのようなクエリが発行されるかは実装によります）。こちらの方がデータベースへのアクセスやクエリ結果の処理が少ないので、データベースへの負荷が低くレスポンスも速い。</p>\n<p>graphql/dataloader の実装は特定のアーキテクチャに依存しないが、 GraphQL の Resolver で非同期処理をすると容易に非効率なクエリが発行されてしまうので、それを防ぐため GraphQL サービスに使われることが多い。</p>\n<p>実は graphql/dataloader や類似のライブラリ以外にも GraphQL でこのような N+1 問題を解決する方法はあるのだが、個人的にはこれが最も単純明快な解決策だと思う。</p>\n<h2>詳細な実装</h2>\n<p>ここからは <a href=\"https://github.com/graphql/dataloader/releases/tag/v2.0.0\">v2.0.0</a> の <a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js\">src/index.js</a> を上から順に読んでいく。</p>\n<p>YouTube の <a href=\"https://www.youtube.com/watch?v=OQTnXNCDywA\">DataLoader - Source code walkthrough</a> の動画が非常に参考になる。この動画は v1 の解説なので最新の v2 とは若干の差があるが、基本的に大きな違いはない。<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup></p>\n<h3>DataLoader flow type: L10-L33</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L10-L33\">10 ~ 33行目</a></p>\n<p>graphql/dataloader では JavaScript に静的な型を付けるために <a href=\"https://flow.org/\">Flow</a> を使用している。</p>\n<p>index.js では最初に以下の3つの type が定義されている。まずは <code class=\"language-text\">BatchLoadFn</code> で、これは Batch 処理の対象 keys <code class=\"language-text\">K</code> を受け取って Values <code class=\"language-text\">V</code> の配列の Promise を返す関数。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// A Function, which when given an Array of keys, returns a Promise of an Array</span>\n<span class=\"token comment\">// of values or Errors.</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">BatchLoadFn<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  <span class=\"token punctuation\">(</span>keys<span class=\"token operator\">:</span> $ReadOnlyArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>$ReadOnlyArray<span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span> <span class=\"token operator\">|</span> Error<span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>次に定義されているのは <code class=\"language-text\">Options</code> で、これにより DataLoader クラスのコンストラクタで初期値を設定できる。例えば Batch の最大サイズや Cache を使うかどうか等の設定をすることができる。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Optionally turn off batching or caching or provide a cache key function or a</span>\n<span class=\"token comment\">// custom cache instance.</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Options<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span> <span class=\"token operator\">=</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  batch<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  maxBatchSize<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  batchScheduleFn<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token function-variable function\">callback</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  cache<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n  cacheKeyFn<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span><span class=\"token punctuation\">;</span>\n  cacheMap<span class=\"token operator\">?</span><span class=\"token operator\">:</span> CacheMap<span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">V</span><span class=\"token operator\">>></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最後に <code class=\"language-text\">CacheMap</code> で、これは通常は使うことはないが、カスタムの Cache を定義したいときはこの型を持つインスタンスを Options として渡す。<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// If a custom cache is provided, it must be of this type (a subset of ES6 Map).</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">CacheMap<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">V</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>type 定義は ES6 で追加された <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a> の subset になっている。</p>\n<h3>DataLoader コンストラクタ: L34-L70</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L34-L70\">34 ~ 70行目</a></p>\n<p>DataLoader のコンストラクタは BatchLoadFn と Options を受け取る。BatchLoadFn は前述の通り Batch 処理対象となる key の配列を受け取って配列の Promise を返す関数で、ユーザーが定義する。</p>\n<p>コンストラクタから呼ばれる関数（getValidMaxBatchSize など）については後述する。</p>\n<h3>load: L71-L113</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L71-L113\">71 ~ 113行目</a></p>\n<p>単一の key を受け取り、それを Batch Function に与えて得られる value の Promise を返す。 value そのものは返さない。</p>\n<p>行数はかなり多いが責任は単純で、</p>\n<ol>\n<li>まず引数の key が null でも undefined でもないことを確かめる</li>\n<li><code class=\"language-text\">getCurrentBatch</code> で load を実行する Batch 処理を取得する</li>\n<li>引数の key で Cache （key と対応する value の Promise）が存在するかを調べ、hit すればそれを返し hit しなければ Batch 処理に key を push してから key と Promise の組み合わせを Cache する</li>\n<li>3 の Promise を返す</li>\n</ol>\n<p>という処理を行なっている。</p>\n<p>load や loadMany をまとめて Batch 処理を実行するのは <code class=\"language-text\">dispatchBatch</code> という別の関数で、これは 2. の <code class=\"language-text\">getCurrentBatch</code> から呼ばれる。</p>\n<h3>loadMany: L114-L148</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L114-L148\">114 ~ 148行目</a></p>\n<p>引数として複数の key を受け取り、それを Batch Function に引数として与えて得る value の配列の Promise を返す。 value の配列そのものは返さない。</p>\n<p>基本的には <code class=\"language-text\">DataLoader.load</code> を <code class=\"language-text\">Promise.all</code> でラップした関数と考えてよい。つまり…</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">[</span> a<span class=\"token punctuation\">,</span> b <span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> myLoader<span class=\"token punctuation\">.</span><span class=\"token function\">loadMany</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上記のコードは、下記のコードとほぼ同じ動作をする。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">[</span> a<span class=\"token punctuation\">,</span> b <span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  myLoader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  myLoader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>異なる点としては、 <code class=\"language-text\">load</code> が失敗した際に <code class=\"language-text\">Promise.all</code> ではまとめて reject するが、 <code class=\"language-text\">loadMany</code> では Error インスタンスを resolve する。</p>\n<h3>clear, clearAll: L149-L174</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L149-L174\">149 ~ 174行目</a></p>\n<p><code class=\"language-text\">clear</code> では key を指定して、それと対応する Cache を消去する。この Cache は DataLoader インスタンスごとに作られている。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> cacheMap <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_cacheMap<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> cacheKey <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_cacheKeyFn</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>cacheKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>積極的に Cache をクリアせずともメモリが枯渇する可能性は非常に低い。なぜなら、基本的には DataLoader インスタンスはリクエスト毎に作られ結果がクライアントに送られた後（参照がなくなるので） GC によってメモリが解放されるからだ。</p>\n<p>実際にこれを使う場面としては、 GraphQL の Mutation 等で key に対応する value が変わって前の Cache を消したいときだろう。</p>\n<p><code class=\"language-text\">clearAll</code> は DataLoader インスタンスの Cache を全て消去する。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">clearAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> cacheMap <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_cacheMap<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>prime: L175-L205</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L175-L205\">175 ~ 205行目</a></p>\n<p>引数として指定した key と value を Cache に書き込む。つまり load することなく Cache を使うことができる。</p>\n<p>value が Error インスタンスの場合は reject された Promise を Cache する。また、既に指定された key に対して何らかの value が Cache されている場合は何もしないので、上書きしたければ <code class=\"language-text\">clear</code> してから <code class=\"language-text\">prime</code> を呼び出す必要がある。</p>\n<p>これは <code class=\"language-text\">load</code> や <code class=\"language-text\">loadMany</code> によって書き込まれた Cache と挙動を揃えるため。</p>\n<h3>enqueuePostPromiseJob: L206-L246</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L206-L246\">206 ~ 246行目</a></p>\n<p>デフォルトの Batch Scheduling を定義する。</p>\n<p>DataLoader のコンストラクタで <code class=\"language-text\">batchScheduleFn</code> を渡さない場合、この enqueuePostPromiseJob で Batch 処理のスケジューリングを行う。その場合、この関数は次の手順で呼び出される。</p>\n<ul>\n<li><code class=\"language-text\">DataLoader.load</code> が <code class=\"language-text\">getCurrentBatch</code> を呼ぶ</li>\n<li><code class=\"language-text\">getCurrentBatch</code> は dispatch 待機中の Batch が無い場合、新しい Batch を作る</li>\n<li>この時、 <code class=\"language-text\">DataLoader._batchScheduleFn</code> のコールバックとして <code class=\"language-text\">dispatchBatch</code> を呼び新しく作った Batch を実行する\n<ul>\n<li>この時デフォルトで使われる <code class=\"language-text\">_batchScheduleFn</code> がこの <code class=\"language-text\">enqueuePostPromiseJob</code></li>\n</ul>\n</li>\n</ul>\n<p>実装としては次のようになっている。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> enqueuePostPromiseJob <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">typeof</span> process <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> process<span class=\"token punctuation\">.</span>nextTick <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span>\n    <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>resolvedPromise<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        resolvedPromise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      resolvedPromise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token operator\">:</span>\n    setImmediate <span class=\"token operator\">||</span> setTimeout<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Private: cached resolved Promise instance</span>\n<span class=\"token keyword\">var</span> resolvedPromise<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Node.js 環境では <a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">process.nextTick</a> が使われる。nextTick に渡したコールバックは Node.js におけるイベントループ内の各 phase の終了時に実行される。各 phase には実行するコールバックの FIFO キューがあり、その phase に固有の operation を実行した後キューがなくなるかコールバックの最大数に達するまでコールバックを実行する。</p>\n<p>ここでは Promise の then コールバックで process.nextTick を呼び出しているが、これは他の Promise より前に nextTick が呼ばれないようにするため。この技法は<a href=\"https://youtu.be/OQTnXNCDywA?t=1434\">解説動画の 23:55~</a> で説明されている。</p>\n<p>process.nextTick の注意点としては、全てのコールバックが nextTick を呼んだ時点の phase 終了後イベントループを継続する前に呼ばれるので、再帰的に呼び続けると I/O が実行できなくなる恐れがある。イベントループについて詳しくは Node.js のドキュメントを参照。</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/dont-block-the-event-loop/\">Don’t Block the Event Loop (or the Worker Pool)</a></li>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n</ul>\n<p>下記の Synk 社のブログも参考になる。</p>\n<ul>\n<li><a href=\"https://snyk.io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-starve-io/\">Node.js Event-Loop: How even quick Node.js async functions can block the Event-Loop, starve I/O</a></li>\n</ul>\n<p>なおブラウザ環境には Node.js の process.nextTick が無いので、 setImmediate や setTimeout を介して同様の処理が実行される。この場合、パフォーマンスが少し落ちる可能性がある。</p>\n<h3>Batch flow type: L247-L257</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L247-L257\">247 ~ 257行目</a></p>\n<p>ユーザーが定義する Batch Function の実行状況に責任を持つオブジェクトの型を定義している。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Batch<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  hasDispatched<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// batch が dispatch されたかどうかのステータス</span>\n  keys<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// batch function に与える key の配列</span>\n  callbacks<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// batch promise の完了時に実行される callback</span>\n    <span class=\"token function-variable function\">resolve</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function-variable function\">reject</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>error<span class=\"token operator\">:</span> Error<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  cacheHits<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>getCurrentBatch: L258-L287</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L258-L287\">258 ~ 287行目</a></p>\n<p>DataLoader インスタンスを引数に取り、 Batch （の実行状況）を返す。</p>\n<p>返す Batch はまだ dispatch されていない待機中の Batch があるかどうかによって2種類に分かれる。</p>\n<ul>\n<li><code class=\"language-text\">ある</code>: その Batch を返す</li>\n<li><code class=\"language-text\">なし</code>: 新しい Batch オブジェクトを作り、それを <code class=\"language-text\">dispatchBatch</code> で実行する</li>\n</ul>\n<p>なお、待機中の Batch にはコンストラクタで設定できる <code class=\"language-text\">maxBatchSize</code> に到達するまで取得対象の key を追加し続けることができる。 maxBatchSize のデフォルトは Infinity だが、実際には次の tick で Batch が dispatch されるので無限に追加されていくことはない。</p>\n<p><code class=\"language-text\">getCurrentBatch</code> という名前だが、この関数の責任としては Batch を作成したり返すだけでなく（この関数が load から呼ばれることで）Batch を dispatch することも含まれている。</p>\n<h3>dispatchBatch: L288-L352</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L288-L352\">288 ~ 352行目</a></p>\n<p>これも行数は多いが責任は単純で、</p>\n<ul>\n<li>Batch の発行ステータス（hasDispatched）を true にする</li>\n<li>load 対象の key 配列が空であれば Cache を返す</li>\n<li>load 対象の key があれば、 key を与えて Batch Function を実行する\n<ul>\n<li>Batch Function が不正、または実行そのものに失敗した場合は failedDispatch を呼ぶ</li>\n<li>成功した場合は結果が配列かつ与えた key と同じ長さであることを確かめ、個々の value の型（Error インスタンスかどうか）に沿って reject または resolve していく</li>\n</ul>\n</li>\n</ul>\n<p>この dispatchBatch を呼んでいるのは getCurrentBatch のみで、これを呼んでいるのは load のみなので、 <code class=\"language-text\">DataLoader.load</code> を呼んだ時は次のような手順で dispatch される。</p>\n<ul>\n<li>getCurrentBatch を呼んで dispatch されていない待機中の Batch があるか確認する</li>\n<li>待機中の Batch があれば、そこに取得対象の key を追加する</li>\n<li>なければ新しく作って dispatch し、そこに取得対象の key を追加する</li>\n</ul>\n<p>Batch の実行間隔はデフォルト 1 tick で、コンストラクタから渡せる <code class=\"language-text\">batchScheduleFn</code> でカスタマイズできる。</p>\n<h3>failedDispatch: L353-L367</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L353-L367\">353 ~ 367行目</a></p>\n<p>Batch 実行に失敗したときに key と対応する Cache を消して、 Batch に登録された callback の Promise を reject する。</p>\n<p>これは Batch Function に与える key 毎に行われる。もし Cache に hit した場合は（Batch の実行に失敗しても）Cache を返して resolve する。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Private: do not cache individual loads if the entire batch dispatch fails,</span>\n<span class=\"token comment\">// but still reject each request so they do not hang.</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">failedDispatch</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  loader<span class=\"token operator\">:</span> DataLoader<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  batch<span class=\"token operator\">:</span> Batch<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  error<span class=\"token operator\">:</span> Error\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Cache hits are resolved, even though the batch failed.</span>\n  <span class=\"token function\">resolveCacheHits</span><span class=\"token punctuation\">(</span>batch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> batch<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    loader<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>batch<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    batch<span class=\"token punctuation\">.</span>callbacks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Batch 失敗時に Cache を消す理由は、呼び出し側で reject を捕捉してリトライしたときに Cache hit しないようにするため。</p>\n<h3>resolveCacheHits: L368-L376</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L368-L376\">368 ~ 376行目</a></p>\n<p>Batch を引数に取り、その中で Cache に hit した Promise を resolve するだけの関数。</p>\n<h3>getValidMaxBatchSize: L377-L394</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L377-L394\">377 ~ 394行目</a></p>\n<p>DataLoader のコンストラクタから呼び出され、 Batch の最大サイズを返す。デフォルトは Infinity。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Private: given the DataLoader's options, produce a valid max batch size.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getValidMaxBatchSize</span><span class=\"token punctuation\">(</span>options<span class=\"token operator\">:</span> <span class=\"token operator\">?</span>Options<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> shouldBatch <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>options <span class=\"token operator\">||</span> options<span class=\"token punctuation\">.</span>batch <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>shouldBatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">var</span> maxBatchSize <span class=\"token operator\">=</span> options <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>maxBatchSize<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxBatchSize <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">Infinity</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> maxBatchSize <span class=\"token operator\">!==</span> <span class=\"token string\">'number'</span> <span class=\"token operator\">||</span> maxBatchSize <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">maxBatchSize must be a positive number: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">(</span>maxBatchSize<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> maxBatchSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Batch の最大サイズを制限すると、 getCurrentBatch で待機中の Batch をより細かく切り分けて実行することができる。</p>\n<h3>getValidBatchScheduleFn: L395-L410</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L395-L410\">395 ~ 410行目</a></p>\n<p>DataLoader のコンストラクタから呼び出され、 Batch を Schedule する関数を返す。</p>\n<p>デフォルトでは <code class=\"language-text\">enqueuePostPromiseJob</code> を使う。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Private</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getValidBatchScheduleFn</span><span class=\"token punctuation\">(</span>\n  options<span class=\"token operator\">:</span> <span class=\"token operator\">?</span>Options<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> batchScheduleFn <span class=\"token operator\">=</span> options <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>batchScheduleFn<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>batchScheduleFn <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> enqueuePostPromiseJob<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> batchScheduleFn <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">batchScheduleFn must be a function: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">(</span>batchScheduleFn<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> batchScheduleFn<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>getValidCacheKeyFn: L411-L422</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L411-L422\">411 ~ 422行目</a></p>\n<p>DataLoader のコンストラクタから呼び出され、 key を通じて Cache から key と value の組み合わせを取得する関数を返す。</p>\n<p>デフォルトは <code class=\"language-text\">(key => key: any);</code> を返す。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Private: given the DataLoader's options, produce a cache key function.</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">getValidCacheKeyFn</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>options<span class=\"token operator\">:</span> <span class=\"token operator\">?</span>Options<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">K</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> cacheKeyFn <span class=\"token operator\">=</span> options <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>cacheKeyFn<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheKeyFn <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">=></span> key<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> cacheKeyFn <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">cacheKeyFn must be a function: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">(</span>cacheKeyFn<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> cacheKeyFn<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>key が string や number であればデフォルトで問題ないが、オブジェクトを key として使いたい場合は CacheKeyFn が必要になってくる。例えば MongoDB など。</p>\n<h3>getValidCacheMap: L423-L447</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L423-L447\">423 ~ 447行目</a></p>\n<p>DataLoader のコンストラクタから呼び出され、 Cache を書き込むためのインスタンスを返す。コンストラクタに渡すオプションで Cache を無効にすることもでき、その場合はこの関数が null を返す。</p>\n<p>デフォルトでは ES6 で追加された <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a> オブジェクトを使う。</p>\n<h3>isArrayLike: L448-L458</h3>\n<p><a href=\"https://github.com/graphql/dataloader/blob/ef6d32f97cde16aba84d96dc806c4439eaf8efae/src/index.js#L448-L458\">448 ~ 458行目</a></p>\n<p>引数が配列かどうかを boolean で返す関数で、下記の2箇所で使われている。</p>\n<ul>\n<li>loadMany に key の配列を与えたときそれが配列でなければ例外を投げる</li>\n<li>dispatchBatch において、 Batch Function の Promise を resolve した結果が配列でなければ例外を投げる</li>\n</ul>\n<p>isArrayLike 関数に次のような引数を与えると、各行にコメントで記した結果を返す。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">undefined</span> <span class=\"token comment\">// false</span>\n<span class=\"token keyword\">null</span> <span class=\"token comment\">// false</span>\n<span class=\"token string\">'x'</span> <span class=\"token comment\">// false</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token string\">'foo'</span><span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bar'</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'foo'</span><span class=\"token operator\">:</span> <span class=\"token number\">300</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bar'</span><span class=\"token operator\">:</span> <span class=\"token number\">400</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>最後の条件では配列がその最後の要素を持つかどうかを判定している。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">x<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span>\n  <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>ロジックだけ読むと何のためかよく分からないのだが、 Object.prototype が上書きされた場合に安全に配列の要素を参照するためかもしれない。</p>\n<p>参考: <a href=\"https://sosukesuzuki.dev/posts/stage-3-object-hasown/\">https://sosukesuzuki.dev/posts/stage-3-object-hasown/</a></p>\n<h2>DataLoader の基本的な使い方</h2>\n<ul>\n<li>まずは <strong>Batch Function</strong> を定義する\n<ul>\n<li>取得対象のデータを示す key の配列を受け取り、それと対応する value 配列の Promise を返す</li>\n</ul>\n</li>\n<li><strong>Batch Function</strong> をコンストラクタに渡して <code class=\"language-text\">DataLoader</code> のインスタンスを作る</li>\n<li>データを取得するときは <code class=\"language-text\">DataLoader.load(key)</code> を使う\n<ul>\n<li>これにより、同じ Batch Scheduling 内に行われたデータ取得リクエストを DataLoader が一つにまとめてくれる（<a href=\"https://github.com/graphql/dataloader#batch-scheduling\">参考</a>）</li>\n<li>実際の挙動としては <strong>Batch Function</strong> に key の配列が渡されて実行される</li>\n<li>load は引数として与えた key に対応する value の Promise を返す</li>\n</ul>\n</li>\n<li><code class=\"language-text\">DataLoader</code> インスタンスごとに <code class=\"language-text\">Cache</code> の Map が作られる\n<ul>\n<li>key とそれに対応する value の Promise の組が入っている</li>\n<li>異なるクライアントのリクエストを Cache すると見えてはいけないものが見えてしまうので、必ずリクエスト毎あるいはクライアント毎に DataLoader インスタンスを作ること</li>\n</ul>\n</li>\n</ul>\n<h2>DataLoader について書かれた記事</h2>\n<p>最後に DataLoader について書かれた記事を紹介する。実際に graphql/dataloader を使ってはいなくとも、基本的なアイデアとしては共通している。</p>\n<ul>\n<li><a href=\"https://engineering.mercari.com/blog/entry/20210818-mercari-shops-nestjs-graphql-server\">mercari engineering: メルカリ Shops での NestJS を使った GraphQL Server の実装</a></li>\n<li><a href=\"https://dev.classmethod.jp/articles/graphql-dataloader-sample/\">クラスメソッド: [GraphQL] N+1 問題を解決する DataLoader の仕組みとサンプル実装</a></li>\n<li><a href=\"https://qiita.com/yuku_t/items/2c1735cbf45e75c0bfb8\">Qiita: GraphQL と N+1 SQL 問題と dataloader</a></li>\n<li><a href=\"https://zenn.dev/tatta/books/5096cb23126e64/viewer/e1ddb1\">Zenn: TypeScript * GraphQL のバックエンド設計プラクティス</a></li>\n<li><a href=\"https://zenn.dev/alea12/articles/15d73282c3aacc\">Zenn: GraphQL で N+1 問題を解決する４つのアプローチ</a></li>\n<li><a href=\"https://blog.potproject.net/2021/02/26/dataloader-architecture\">最適化されたデータの取得をしてくれるDataloaderの仕組みを調べてみた</a></li>\n</ul>\n<h2>勉強になった点</h2>\n<p>graphql/dataloader は自分自身のプログラミングの勉強になったので、感想を書いておく。</p>\n<p>これは簡潔かつ短いコードで限られた機能を提供しているが、非常に多くの人に使われている。多くの人に使われている理由は、 GraphQL の非同期 Resolver で出会う可能性が非常に高い問題を簡単に解決できるからだろう。</p>\n<p>それを簡単に解決できる理由としては、大元のアイデア（一定時間内のデータ取得リクエストを Batch 処理としてまとめ、データソースへのリクエスト回数を減らす）が単純に優れているだけでなく、アイデアを実現するために graphql/dataloader が責任を持つ範囲を明確に限定しているという点を挙げたい。</p>\n<p>graphql/dataloader の責任はデータ取得リクエストの Batch とその Cache であり、その中でも一部に限られている。 Batch 処理を行う関数はユーザー側が定義して DataLoader コンストラクタに渡す。Batch も Cache もインターフェイスは決まっているが、それさえ守ればユーザー側でカスタマイズできる。</p>\n<p>特定のアーキテクチャに依存するのはユーザーが実装する Batch Function やユーザーが与える CacheMap であり、 graphql/dataloader 自体は非同期でサービス内の様々な箇所から同じデータベースに向けて効率的なデータ取得要求をしたいというユースケースを上手に抽象化し、特定のアーキテクチャに依存しない実装となっている。これは簡単で分かりやすく、使いやすい設計といえる。</p>\n<p>機能に関して言えば、このような DataLoader は ORM の機能として実現することもできる（例えば <a href=\"https://www.prisma.io/docs/guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader\">Prisma のように</a>）。しかし、 graphql/dataloader のように小さく責任範囲が明確で上手に実装されているライブラリは、実装を把握するのが簡単、組み込みやすい、取り替えやすいなど様々なメリットがあると考えられる。</p>\n<p>少人数で大きな価値を生み出すにはこのようにプログラムの責任を明確にしていくことが重要だと感じたので、自分もこれを心がけていきたい。</p>\n<h2>本記事のまとめ</h2>\n<ul>\n<li>graphql/dataloader の本質は Batch と Cache の機能を提供する簡潔な API</li>\n<li>GraphQL におけるデータ取得の問題を簡単に解決してくれるのでよく使われる</li>\n<li>単純かつ率直な実装で素晴らしいアイデアを実装しており、プログラミングの参考になる</li>\n</ul>\n<p>本記事に誤りがあれば Twitter の DM や GitHub の連絡先へのメール等で教えていただけると助かります。どうぞよろしくお願いいたします。</p>\n<p>最後に、今回 Node.js の非同期処理について調べていて最も自分に刺さった言葉を置いておきます。</p>\n<blockquote>\n<p>the way that you should be doing things should be easy in the way you shouldn’t be doing things should be difficult</p>\n</blockquote>\n<p>— <a href=\"https://youtu.be/EeYvFl7li9E?t=1455\">Ryan Dahl: Node JS, JSConf.eu 2009</a></p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">他言語による実装では Go の <a href=\"https://github.com/graph-gophers/dataloader\">graph-gophers/dataloader</a> や Ruby の <a href=\"https://github.com/Shopify/graphql-batch\">exAspArk/batch-loader</a>、<a href=\"https://github.com/Shopify/graphql-batch\">Shopify/graphql-batch</a> がよく使われているようだ。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">ただし Batch Function 内部で N+1 問題を引き起こすようなループ処理内でのクエリ発行を行っている場合は、当然ながら N+1 問題が発生してしまう。もっとも、これは GraphQL の Resolver が起こすそれに比べればコード上で明確なぶん与しやすそうだ。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://graphql.org/learn/execution/\">https://graphql.org/learn/execution/</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://graphql.org/learn/execution/#asynchronous-resolvers\">https://graphql.org/learn/execution/#asynchronous-resolvers</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://graphql.org/learn/execution/#list-resolvers\">https://graphql.org/learn/execution/#list-resolvers</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\">load や loadMany には v2.0.0 で breaking change があるので、詳しく知りたい場合は <a href=\"https://github.com/graphql/dataloader/releases/tag/v2.0.0\">Releases/v2.0.0</a> を見ると良い。<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\">DataLoader の Cache はデフォルトで無限に成長し、 DataLoader インスタンスへの参照がなくなったときに GC によってメモリが解放される。通常はリクエスト単位でインスタンスを作るので、 Cache は GC されメモリがすぐ解放されるため問題になることはない。開発者 Lee Byron 氏の<a href=\"https://youtu.be/OQTnXNCDywA?t=619\">解説動画 10:19 ~</a>によれば、 Facebook でもそのような実装になっているようだ。<a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"graphql/dataloader を読んだ話","date":"December 16, 2021","description":null}},"previous":{"fields":{"slug":"/2021-11-25-elastic/"},"frontmatter":{"title":"Elastic 社の決算を読んだ話"}},"next":null},"pageContext":{"id":"78d2df38-a6ac-5ddd-950c-b9f96daff7f6","previousPostId":"1bf7f504-474b-5f5c-9919-5cc1a5e27b70","nextPostId":null}},
    "staticQueryHashes": ["1445466728","2841359383"]}